---
phase: 04-web-demo
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/browser.ts
  - src/url/fragment.browser.ts
  - demo/lib.js
  - demo/keystore.js
  - scripts/build-demo.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Browser bundle loads without Buffer errors"
    - "generateKeyPair works in browser context"
    - "encrypt/decrypt work in browser context"
    - "Keys can be saved to localStorage with names"
    - "Keys can be loaded from localStorage"
    - "Keys can be deleted from localStorage"
  artifacts:
    - path: "src/browser.ts"
      provides: "Browser entry point re-exporting library"
      exports: ["generateKeyPair", "encrypt", "decrypt", "encodeCoseKey", "decodeCoseKey", "toDiagnostic", "createShareableUrl", "parseShareableUrl", "encodeFragment", "decodeFragment"]
    - path: "src/url/fragment.browser.ts"
      provides: "Browser-compatible base64url encoding"
      exports: ["toBase64Url", "fromBase64Url", "encodeFragment", "decodeFragment"]
    - path: "demo/lib.js"
      provides: "Bundled library for browser"
      min_lines: 100
    - path: "demo/keystore.js"
      provides: "localStorage key management"
      exports: ["getKeys", "saveKey", "deleteKey", "hexToBytes", "bytesToHex", "getKeyFingerprint"]
    - path: "scripts/build-demo.ts"
      provides: "Build script for browser bundle"
  key_links:
    - from: "src/browser.ts"
      to: "src/url/fragment.browser.ts"
      via: "import for browser-compatible base64"
      pattern: "fragment\\.browser"
    - from: "demo/keystore.js"
      to: "localStorage"
      via: "getItem/setItem calls"
      pattern: "localStorage\\.(get|set)Item"
---

<objective>
Create browser-compatible bundle and key management module for the web demo.

Purpose: Establish foundation for the browser UI by solving the Buffer compatibility issue and providing localStorage key persistence.
Output: Browser bundle (demo/lib.js) and keystore module (demo/keystore.js) ready for UI integration.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-web-demo/04-CONTEXT.md
@.planning/phases/04-web-demo/04-RESEARCH.md
@src/index.ts
@src/url/fragment.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create browser-compatible fragment module and bundle entry point</name>
  <files>
    src/url/fragment.browser.ts
    src/browser.ts
    scripts/build-demo.ts
    demo/lib.js
  </files>
  <action>
Create a browser-compatible version of fragment.ts that replaces Buffer.from with browser-native APIs:

1. Create `src/url/fragment.browser.ts`:
   - Copy logic from `src/url/fragment.ts`
   - Replace `Buffer.from(bytes).toString('base64')` with:
     ```typescript
     let binary = '';
     for (let i = 0; i < bytes.length; i++) {
       binary += String.fromCharCode(bytes[i]);
     }
     const base64 = btoa(binary);
     ```
   - Replace `Buffer.from(base64, 'base64')` with:
     ```typescript
     const binary = atob(base64);
     const bytes = new Uint8Array(binary.length);
     for (let i = 0; i < binary.length; i++) {
       bytes[i] = binary.charCodeAt(i);
     }
     ```
   - Keep version prefix logic (0x00, 0x01) unchanged
   - Import compress/decompress from './compress.ts' (these are already browser-compatible via CompressionStream)

2. Create `src/browser.ts`:
   - Re-export all public API from main library
   - BUT override fragment functions with browser-compatible versions
   - Structure:
     ```typescript
     // Core library exports
     export { generateKeyPair, encrypt, decrypt, encodeCoseKey, decodeCoseKey, toDiagnostic } from './index.ts';

     // Browser-compatible URL transport (override fragment functions)
     export { toBase64Url, fromBase64Url, encodeFragment, decodeFragment } from './url/fragment.browser.ts';
     export { compress, decompress, isCompressionAvailable } from './url/compress.ts';
     export { createShareableUrl, parseShareableUrl, MAX_URL_LENGTH, BASE_URL, UrlTooLargeError } from './url/index.ts';
     ```
   - Note: createShareableUrl/parseShareableUrl will use the browser versions because they import from fragment.browser.ts at bundle time

   WAIT - createShareableUrl imports from fragment.ts, not fragment.browser.ts. Need different approach:
   - Create browser-specific URL module OR
   - Re-implement createShareableUrl/parseShareableUrl in browser.ts using browser fragment functions

   Simpler approach: Re-implement in browser.ts:
   ```typescript
   import { encodeFragment, decodeFragment } from './url/fragment.browser.ts';

   export const MAX_URL_LENGTH = 2 * 1024 * 1024;
   export const BASE_URL = 'https://cose-hpke.github.io/decrypt';

   export class UrlTooLargeError extends Error { /* copy from url/index.ts */ }

   export async function createShareableUrl(ciphertext: Uint8Array, baseUrl = BASE_URL): Promise<string> {
     const fragment = await encodeFragment(ciphertext);
     const url = `${baseUrl}#${fragment}`;
     if (url.length > MAX_URL_LENGTH) throw new UrlTooLargeError(url.length, MAX_URL_LENGTH);
     return url;
   }

   export async function parseShareableUrl(url: string): Promise<Uint8Array> {
     const parsed = new URL(url);
     const fragment = parsed.hash.slice(1);
     if (!fragment) throw new Error('URL has no fragment');
     return decodeFragment(fragment);
   }
   ```

3. Create `scripts/build-demo.ts`:
   ```typescript
   await Bun.build({
     entrypoints: ['./src/browser.ts'],
     outdir: './demo',
     outfile: 'lib.js',
     target: 'browser',
     format: 'esm',
     minify: true,
     sourcemap: 'linked',
   });
   console.log('Browser bundle created: demo/lib.js');
   ```

4. Add build script to package.json:
   ```json
   "build:demo": "bun run scripts/build-demo.ts"
   ```

5. Run build and verify output exists:
   ```bash
   bun run build:demo
   ls -la demo/lib.js
   ```
  </action>
  <verify>
- `bun run build:demo` completes without errors
- `demo/lib.js` exists and is minified (check file size)
- `demo/lib.js.map` sourcemap exists
- No "Buffer" references in demo/lib.js (grep -c "Buffer" demo/lib.js returns 0)
  </verify>
  <done>
Browser bundle exists at demo/lib.js, is minified, and contains no Node.js Buffer references.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create localStorage key management module</name>
  <files>
    demo/keystore.js
  </files>
  <action>
Create `demo/keystore.js` as a standalone ES module for localStorage key management:

```javascript
// Key storage for COSE-HPKE web demo
// Keys stored as: { name: string, keyHex: string, type: 'public' | 'private', created: number }

const STORAGE_KEY = 'cose-hpke-keys';

/**
 * Get all stored keys.
 * @returns {Array<{name: string, keyHex: string, type: 'public' | 'private', created: number}>}
 */
export function getKeys() {
  const data = localStorage.getItem(STORAGE_KEY);
  return data ? JSON.parse(data) : [];
}

/**
 * Get keys filtered by type.
 * @param {'public' | 'private'} type
 */
export function getKeysByType(type) {
  return getKeys().filter(k => k.type === type);
}

/**
 * Save a key to localStorage.
 * @param {string} name - User-friendly name
 * @param {Uint8Array} keyBytes - CBOR-encoded COSE_Key
 * @param {'public' | 'private'} type
 */
export function saveKey(name, keyBytes, type) {
  const keys = getKeys();

  // Check for duplicate name+type
  if (keys.some(k => k.name === name && k.type === type)) {
    throw new Error(`Key "${name}" (${type}) already exists`);
  }

  keys.push({
    name,
    keyHex: bytesToHex(keyBytes),
    type,
    created: Date.now(),
  });

  localStorage.setItem(STORAGE_KEY, JSON.stringify(keys));
}

/**
 * Delete a key from localStorage.
 * @param {string} name
 * @param {'public' | 'private'} type
 */
export function deleteKey(name, type) {
  const keys = getKeys().filter(k => !(k.name === name && k.type === type));
  localStorage.setItem(STORAGE_KEY, JSON.stringify(keys));
}

/**
 * Convert hex string to Uint8Array.
 * @param {string} hex
 * @returns {Uint8Array}
 */
export function hexToBytes(hex) {
  const bytes = new Uint8Array(hex.length / 2);
  for (let i = 0; i < hex.length; i += 2) {
    bytes[i / 2] = parseInt(hex.slice(i, i + 2), 16);
  }
  return bytes;
}

/**
 * Convert Uint8Array to hex string.
 * @param {Uint8Array} bytes
 * @returns {string}
 */
export function bytesToHex(bytes) {
  return Array.from(bytes)
    .map(b => b.toString(16).padStart(2, '0'))
    .join('');
}

/**
 * Generate a short fingerprint for a key (first 8 hex chars of SHA-256 hash).
 * @param {Uint8Array} keyBytes
 * @returns {Promise<string>}
 */
export async function getKeyFingerprint(keyBytes) {
  const hashBuffer = await crypto.subtle.digest('SHA-256', keyBytes);
  const hashArray = new Uint8Array(hashBuffer);
  return Array.from(hashArray.slice(0, 4))
    .map(b => b.toString(16).padStart(2, '0'))
    .join('');
}

/**
 * Clear all stored keys (for testing/reset).
 */
export function clearAllKeys() {
  localStorage.removeItem(STORAGE_KEY);
}
```
  </action>
  <verify>
- File exists at `demo/keystore.js`
- File has valid ES module syntax (export statements)
- All exported functions are documented with JSDoc
  </verify>
  <done>
Key management module exists at demo/keystore.js with getKeys, saveKey, deleteKey, hexToBytes, bytesToHex, getKeyFingerprint exports.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add browser bundle test</name>
  <files>
    test/browser-bundle.test.ts
  </files>
  <action>
Create a test to verify the browser bundle builds correctly and has expected exports:

```typescript
import { describe, it, expect, beforeAll } from 'bun:test';
import { existsSync, readFileSync } from 'fs';

describe('Browser Bundle', () => {
  beforeAll(async () => {
    // Build the demo bundle
    const proc = Bun.spawn(['bun', 'run', 'build:demo'], {
      cwd: process.cwd(),
      stdout: 'inherit',
      stderr: 'inherit',
    });
    await proc.exited;
  });

  it('creates demo/lib.js', () => {
    expect(existsSync('demo/lib.js')).toBe(true);
  });

  it('creates sourcemap', () => {
    expect(existsSync('demo/lib.js.map')).toBe(true);
  });

  it('does not contain Buffer references', () => {
    const content = readFileSync('demo/lib.js', 'utf-8');
    // Check for common Buffer patterns
    expect(content).not.toContain('Buffer.from');
    expect(content).not.toContain('Buffer.alloc');
  });

  it('exports expected functions', async () => {
    // Dynamic import the built bundle
    const lib = await import('../demo/lib.js');

    // Core functions
    expect(typeof lib.generateKeyPair).toBe('function');
    expect(typeof lib.encrypt).toBe('function');
    expect(typeof lib.decrypt).toBe('function');
    expect(typeof lib.encodeCoseKey).toBe('function');
    expect(typeof lib.decodeCoseKey).toBe('function');
    expect(typeof lib.toDiagnostic).toBe('function');

    // URL transport functions
    expect(typeof lib.createShareableUrl).toBe('function');
    expect(typeof lib.parseShareableUrl).toBe('function');
    expect(typeof lib.encodeFragment).toBe('function');
    expect(typeof lib.decodeFragment).toBe('function');
    expect(typeof lib.toBase64Url).toBe('function');
    expect(typeof lib.fromBase64Url).toBe('function');
  });

  it('can generate keypair', async () => {
    const lib = await import('../demo/lib.js');
    const keypair = await lib.generateKeyPair();

    expect(keypair.publicKey).toBeInstanceOf(Uint8Array);
    expect(keypair.privateKey).toBeInstanceOf(Uint8Array);
    expect(keypair.publicKey.length).toBeGreaterThan(0);
    expect(keypair.privateKey.length).toBeGreaterThan(0);
  });

  it('can encrypt and decrypt', async () => {
    const lib = await import('../demo/lib.js');
    const keypair = await lib.generateKeyPair();
    const plaintext = new TextEncoder().encode('Hello, browser!');

    const ciphertext = await lib.encrypt(plaintext, [keypair.publicKey]);
    const decrypted = await lib.decrypt(ciphertext, keypair.privateKey);

    expect(new TextDecoder().decode(decrypted)).toBe('Hello, browser!');
  });

  it('can create and parse shareable URL', async () => {
    const lib = await import('../demo/lib.js');
    const keypair = await lib.generateKeyPair();
    const plaintext = new TextEncoder().encode('URL test');

    const ciphertext = await lib.encrypt(plaintext, [keypair.publicKey]);
    const url = await lib.createShareableUrl(ciphertext);

    expect(url).toContain('#');
    expect(url.startsWith('https://cose-hpke.github.io/decrypt#')).toBe(true);

    const parsed = await lib.parseShareableUrl(url);
    expect(parsed).toBeInstanceOf(Uint8Array);
    expect(parsed.length).toBe(ciphertext.length);
  });
});
```

Run the test:
```bash
bun test test/browser-bundle.test.ts
```
  </action>
  <verify>
- `bun test test/browser-bundle.test.ts` passes all tests
- All 7 test cases pass (bundle exists, no Buffer, exports, keypair, encrypt/decrypt, URL)
  </verify>
  <done>
Browser bundle test passes, verifying the bundle builds correctly, has no Buffer references, exports expected functions, and can perform cryptographic operations.
  </done>
</task>

</tasks>

<verification>
Run full test suite to ensure no regressions:
```bash
bun test
```

Verify bundle size is reasonable (should be under 100KB gzipped):
```bash
gzip -c demo/lib.js | wc -c
```
</verification>

<success_criteria>
1. `demo/lib.js` exists and is minified
2. No Buffer references in the bundle
3. Browser bundle test passes (7 tests)
4. `demo/keystore.js` exists with localStorage functions
5. All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-web-demo/04-01-SUMMARY.md`
</output>
