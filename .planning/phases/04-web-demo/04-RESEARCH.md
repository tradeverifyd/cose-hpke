# Phase 4: Web Demo - Research

**Researched:** 2026-01-19
**Domain:** Browser bundling, Web Cryptography, localStorage key management, QR generation, Tailwind CSS
**Confidence:** HIGH

## Summary

This phase creates a browser-based demo for COSE-HPKE encryption/decryption. The existing library uses `hpke` (by @panva) and `cbor2`, both of which are explicitly designed for browser environments with ESM exports and Web Cryptography API usage. The core challenge is bundling the library for browser use and handling Node.js-specific APIs like `Buffer` that appear in some modules.

The recommended approach is to use Bun's bundler to create a browser-compatible ESM bundle, replacing `Buffer` usage with `Uint8Array` and browser-native `btoa`/`atob` for base64 operations. The UI will be a single HTML page with Tailwind CSS via CDN for styling, localStorage for key persistence, and a lightweight QR code library for shareable URL generation.

**Primary recommendation:** Create a browser bundle with `bun build --target browser`, use lean-qr for QR codes (~4kB), Tailwind CSS v4 CDN for styling, and a single `index.html` file with inline JavaScript for GitHub Pages deployment.

## Standard Stack

The established libraries/tools for this domain:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| hpke | 1.0.3 | HPKE encryption | Already in project, browser-native via WebCrypto |
| cbor2 | 2.0.1 | CBOR encoding | Already in project, "web-first" design |
| Tailwind CSS | v4 CDN | Styling | No build step, JIT in browser |
| lean-qr | latest | QR code generation | ~4kB compressed, no dependencies |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| Bun bundler | built-in | Browser bundle | Build step for library |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| lean-qr | qrcode npm | qrcode is larger (~50kB), but more features |
| lean-qr | qr-code-styling | More styling options but much larger bundle |
| Tailwind CDN | Built Tailwind | CDN avoids build complexity, fine for demo |
| Single HTML | React/Vue SPA | Framework adds complexity for simple demo |

**Installation:**
```bash
npm install lean-qr
# Tailwind CSS via CDN - no install needed
```

## Architecture Patterns

### Recommended Project Structure
```
demo/
├── index.html           # Single HTML file, loads bundled JS
├── bundle.js            # Bundled library (generated by bun build)
└── bundle.js.map        # Sourcemap (optional)
```

### Pattern 1: Single HTML Page with Tabs
**What:** Tabbed interface in single HTML file with inline styles
**When to use:** Simple demo without routing needs
**Example:**
```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>COSE-HPKE Demo</title>
  <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen">
  <div id="app">
    <!-- Tab navigation -->
    <nav class="flex border-b border-gray-700">
      <button data-tab="keys" class="tab-btn active">Keys</button>
      <button data-tab="encrypt" class="tab-btn">Encrypt</button>
      <button data-tab="decrypt" class="tab-btn">Decrypt</button>
    </nav>

    <!-- Tab content panels -->
    <div data-panel="keys" class="tab-panel active">...</div>
    <div data-panel="encrypt" class="tab-panel hidden">...</div>
    <div data-panel="decrypt" class="tab-panel hidden">...</div>
  </div>
  <script type="module" src="./bundle.js"></script>
  <script type="module">
    // Tab switching logic
    document.querySelectorAll('.tab-btn').forEach(btn => {
      btn.addEventListener('click', () => switchTab(btn.dataset.tab));
    });
  </script>
</body>
</html>
```

### Pattern 2: Browser Bundle Entry Point
**What:** Separate entry point exposing library API globally
**When to use:** Bundling library for browser consumption
**Example:**
```typescript
// src/browser.ts - Browser-specific entry point
import { generateKeyPair, encrypt, decrypt, encodeCoseKey, decodeCoseKey } from './index.ts';
import { createShareableUrl, parseShareableUrl, encodeFragment, decodeFragment } from './url/index.ts';

// Re-export for browser use
export {
  generateKeyPair,
  encrypt,
  decrypt,
  encodeCoseKey,
  decodeCoseKey,
  createShareableUrl,
  parseShareableUrl,
  encodeFragment,
  decodeFragment,
};
```

Build command:
```bash
bun build ./src/browser.ts --outdir ./demo --target browser --format esm --minify
```

### Pattern 3: localStorage Key Store
**What:** Wrapper for localStorage with typed key management
**When to use:** Persisting keys between sessions
**Example:**
```typescript
// Source: Browser localStorage API + project requirements
interface StoredKey {
  name: string;
  keyHex: string;  // CBOR hex encoding (CLI compatible)
  type: 'public' | 'private';
  created: number; // timestamp
}

const STORAGE_KEY = 'cose-hpke-keys';

function getStoredKeys(): StoredKey[] {
  const data = localStorage.getItem(STORAGE_KEY);
  return data ? JSON.parse(data) : [];
}

function saveKey(key: StoredKey): void {
  const keys = getStoredKeys();
  keys.push(key);
  localStorage.setItem(STORAGE_KEY, JSON.stringify(keys));
}

function deleteKey(name: string, type: 'public' | 'private'): void {
  const keys = getStoredKeys().filter(k => !(k.name === name && k.type === type));
  localStorage.setItem(STORAGE_KEY, JSON.stringify(keys));
}

function keyToHex(keyBytes: Uint8Array): string {
  return Array.from(keyBytes)
    .map(b => b.toString(16).padStart(2, '0'))
    .join('');
}

function hexToKey(hex: string): Uint8Array {
  const bytes = new Uint8Array(hex.length / 2);
  for (let i = 0; i < hex.length; i += 2) {
    bytes[i / 2] = parseInt(hex.slice(i, i + 2), 16);
  }
  return bytes;
}
```

### Pattern 4: Browser-Compatible Base64
**What:** Replace Buffer.from with browser-native base64
**When to use:** Any base64 encoding/decoding in browser bundle
**Example:**
```typescript
// Browser-compatible base64url (replaces Buffer.from usage)
function toBase64Url(bytes: Uint8Array): string {
  // Convert Uint8Array to binary string
  let binary = '';
  for (let i = 0; i < bytes.length; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  // Use native btoa, convert to URL-safe
  const base64 = btoa(binary);
  return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
}

function fromBase64Url(str: string): Uint8Array {
  // Restore standard base64
  let base64 = str.replace(/-/g, '+').replace(/_/g, '/');
  const padLen = (4 - (base64.length % 4)) % 4;
  base64 += '='.repeat(padLen);
  // Use native atob
  const binary = atob(base64);
  const bytes = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) {
    bytes[i] = binary.charCodeAt(i);
  }
  return bytes;
}
```

### Pattern 5: QR Code Generation with lean-qr
**What:** Generate QR code for shareable URL
**When to use:** After encryption to show shareable link
**Example:**
```typescript
// Source: lean-qr documentation
import { generate } from 'lean-qr';

function displayQrCode(url: string, canvasElement: HTMLCanvasElement): void {
  const qrCode = generate(url);
  qrCode.toCanvas(canvasElement);
}
```

HTML:
```html
<canvas id="qr-code" style="image-rendering: pixelated; width: 200px;"></canvas>
```

### Anti-Patterns to Avoid

- **Using Node.js Buffer in browser code:** Will fail without polyfill. Use Uint8Array + btoa/atob instead.
- **Storing raw binary keys in localStorage:** localStorage only stores strings. Use hex encoding for CLI compatibility.
- **Complex SPA framework for simple demo:** React/Vue/Svelte add complexity. Vanilla JS with Tailwind is sufficient.
- **Building Tailwind CSS:** CDN v4 handles JIT compilation in browser, no build needed for demos.
- **Large QR libraries:** qr-code-styling and similar are 100kB+. lean-qr is under 4kB.

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| QR code generation | Canvas pixel drawing | lean-qr | Error correction, encoding, rendering handled |
| Styling | Custom CSS | Tailwind CDN | Consistent design system, responsive utilities |
| Key fingerprint | Full hash | First 8 hex chars of key | Good enough for visual identification |
| Tab UI | Custom state management | data attributes + classList | No framework needed for 3 tabs |

**Key insight:** This is a demo, not a production app. Simplicity trumps scalability.

## Common Pitfalls

### Pitfall 1: Buffer Not Defined in Browser
**What goes wrong:** `ReferenceError: Buffer is not defined`
**Why it happens:** The existing `src/url/fragment.ts` uses `Buffer.from()` for base64 encoding
**How to avoid:** Create browser-specific version using `btoa`/`atob` or add Buffer polyfill
**Warning signs:** Works in Bun tests, fails in browser console

### Pitfall 2: Module Not Found for .ts Extensions
**What goes wrong:** Browser cannot load `.ts` files directly
**Why it happens:** TypeScript extensions in imports (`./key.ts`)
**How to avoid:** Bun bundler resolves these - ensure bundling, not direct loading
**Warning signs:** 404 errors for `.ts` files in browser network tab

### Pitfall 3: localStorage Quota Exceeded
**What goes wrong:** `QuotaExceededError` when storing many keys
**Why it happens:** localStorage has 5-10MB limit depending on browser
**How to avoid:** Store keys as hex strings (efficient), warn if quota low
**Warning signs:** Silent failures on key save

### Pitfall 4: Tailwind CDN Not Loading Classes
**What goes wrong:** Tailwind classes appear unstyled
**Why it happens:** Script must load before DOM render, or classes added dynamically after load
**How to avoid:** Ensure Tailwind CDN script is in `<head>`, use `@layer` for dynamic content
**Warning signs:** Classes work in HTML but not when added via JS

### Pitfall 5: CompressionStream Not Available in Old Browsers
**What goes wrong:** `CompressionStream is not defined`
**Why it happens:** Very old browsers (pre-2023) don't support it
**How to avoid:** Feature detection with `typeof CompressionStream !== 'undefined'`
**Warning signs:** Library already has `isCompressionAvailable()` check

### Pitfall 6: URL Fragment Not Parsed on Load
**What goes wrong:** Opening a shareable URL doesn't trigger decryption
**Why it happens:** Fragment changes don't trigger page reload, need to check on load
**How to avoid:** Check `window.location.hash` on page load, parse if present
**Warning signs:** Works when copy-pasting URL, doesn't work when clicking link

### Pitfall 7: Private Keys Visible in DevTools
**What goes wrong:** Users can see private keys in Application > localStorage
**Why it happens:** localStorage is not encrypted
**How to avoid:** Accept this limitation for demo, document it, recommend users don't store high-value keys
**Warning signs:** Security-conscious users asking about key protection

## Code Examples

Verified patterns from official sources:

### Bun Build Configuration
```typescript
// build.ts - Build script for browser bundle
await Bun.build({
  entrypoints: ['./src/browser.ts'],
  outdir: './demo',
  target: 'browser',
  format: 'esm',
  minify: true,
  sourcemap: 'linked',
});

console.log('Browser bundle created in ./demo/');
```

Run with: `bun run build.ts`

### Key Fingerprint Generation
```typescript
// Generate display fingerprint from key bytes
async function getKeyFingerprint(keyBytes: Uint8Array): Promise<string> {
  // SHA-256 hash of the key
  const hashBuffer = await crypto.subtle.digest('SHA-256', keyBytes);
  const hashArray = new Uint8Array(hashBuffer);
  // Take first 4 bytes (8 hex chars)
  return Array.from(hashArray.slice(0, 4))
    .map(b => b.toString(16).padStart(2, '0'))
    .join('');
}
```

### Decrypt with Key Selection
```typescript
// Try all private keys, prioritize by kid hint if available
async function tryDecrypt(
  ciphertext: Uint8Array,
  privateKeys: StoredKey[],
  kidHint?: Uint8Array
): Promise<{ plaintext: Uint8Array; usedKey: string } | null> {
  // Sort keys to try kid-matching key first
  const sortedKeys = [...privateKeys];
  if (kidHint) {
    const kidHex = keyToHex(kidHint);
    sortedKeys.sort((a, b) => {
      const aMatches = a.keyHex.includes(kidHex) ? 1 : 0;
      const bMatches = b.keyHex.includes(kidHex) ? 1 : 0;
      return bMatches - aMatches;
    });
  }

  for (const key of sortedKeys) {
    try {
      const privateKeyBytes = hexToKey(key.keyHex);
      const plaintext = await decrypt(ciphertext, privateKeyBytes);
      return { plaintext, usedKey: key.name };
    } catch {
      // Try next key
      continue;
    }
  }
  return null;
}
```

### Dark Theme Color Palette (Tailwind)
```html
<!-- Recommended dark theme classes for consistency -->
<body class="bg-gray-900 text-gray-100">
  <!-- Card/panel -->
  <div class="bg-gray-800 rounded-lg p-4 shadow-lg">
    <!-- Input fields -->
    <input class="bg-gray-700 border border-gray-600 text-gray-100 rounded px-3 py-2
                  focus:border-blue-500 focus:ring-1 focus:ring-blue-500" />

    <!-- Primary button -->
    <button class="bg-blue-600 hover:bg-blue-700 text-white font-medium px-4 py-2 rounded">
      Encrypt
    </button>

    <!-- Secondary button -->
    <button class="bg-gray-700 hover:bg-gray-600 text-gray-200 px-4 py-2 rounded">
      Cancel
    </button>

    <!-- Danger button -->
    <button class="bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded">
      Delete
    </button>

    <!-- Error message -->
    <p class="text-red-400 text-sm">Decryption failed: wrong key</p>

    <!-- Success message -->
    <p class="text-green-400 text-sm">Message encrypted successfully</p>
  </div>
</body>
```

### GitHub Pages Deployment
```yaml
# .github/workflows/pages.yml
name: Deploy to GitHub Pages

on:
  push:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: read
  pages: write
  id-token: write

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - run: bun install

      - run: bun run build:demo  # Creates demo/ directory

      - uses: actions/upload-pages-artifact@v3
        with:
          path: demo/

      - uses: actions/deploy-pages@v4
```

### Handle URL Fragment on Page Load
```typescript
// Check for encrypted message in URL on page load
document.addEventListener('DOMContentLoaded', async () => {
  const hash = window.location.hash;
  if (hash && hash.length > 1) {
    // Switch to decrypt tab
    switchTab('decrypt');
    // Parse and display encrypted message
    try {
      const fragment = hash.slice(1);
      const ciphertext = await decodeFragment(fragment);
      showDecryptUI(ciphertext);
    } catch (error) {
      showError('Invalid URL: ' + error.message);
    }
  }
});
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Buffer polyfill (~50kB) | Native Uint8Array + btoa/atob | Always available | No polyfill needed |
| Tailwind build step | Tailwind v4 CDN (@tailwindcss/browser) | 2024 | No build required |
| QRCode.js (older) | lean-qr | 2023+ | 4kB vs 50kB |
| Manual GitHub Pages | GitHub Actions workflow | Standard practice | Automatic deployment |

**Deprecated/outdated:**
- **feross/buffer in browser:** Adds 50kB, unnecessary since Uint8Array works everywhere
- **Tailwind v3 CDN:** v4 CDN is current, simpler syntax
- **QRCode.js (davidshimjs):** Unmaintained, lean-qr is smaller and modern

## Open Questions

Things that couldn't be fully resolved:

1. **Exact bundle size after minification**
   - What we know: hpke is tree-shakeable, cbor2 is small, lean-qr is ~4kB
   - What's unclear: Total bundle size with all dependencies
   - Recommendation: Build and measure; target under 100kB gzipped

2. **Custom domain vs github.io URL**
   - What we know: GitHub Pages supports both
   - What's unclear: Whether project will have custom domain
   - Recommendation: Use `https://cose-hpke.github.io/demo` or similar as default base URL

3. **Import/export format for keys**
   - What we know: CLI uses CBOR hex, want interoperability
   - What's unclear: Whether to also support JWK format
   - Recommendation: CBOR hex for CLI compatibility; JWK support can be added later

## Sources

### Primary (HIGH confidence)
- [Bun Bundler Documentation](https://bun.sh/docs/bundler) - Browser target, ESM output, minification
- [hpke GitHub](https://github.com/panva/hpke) - Browser support confirmed, WebCrypto-based
- [cbor2 GitHub](https://github.com/hildjj/cbor2) - "Web-first" design confirmed
- [lean-qr GitHub](https://github.com/davidje13/lean-qr) - 4kB size, canvas API
- [Tailwind CSS v4 CDN](https://tailwindcss.com/docs/installation/play-cdn) - Browser JIT compilation

### Secondary (MEDIUM confidence)
- [MDN CompressionStream](https://developer.mozilla.org/en-US/docs/Web/API/CompressionStream) - Browser support since May 2023
- [GitHub Pages Documentation](https://pages.github.com/) - Static hosting, no build server
- [localStorage MDN](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage) - 5-10MB limit

### Tertiary (LOW confidence)
- [spa-github-pages](https://github.com/rafgraph/spa-github-pages) - SPA routing workaround (not needed for this demo)

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - All libraries are documented and in active use
- Architecture: HIGH - Vanilla JS patterns are well-established
- Pitfalls: HIGH - Buffer issue verified by grep of codebase
- Browser compatibility: MEDIUM - CompressionStream baseline is May 2023

**Research date:** 2026-01-19
**Valid until:** 2026-03-19 (60 days - stable APIs)
