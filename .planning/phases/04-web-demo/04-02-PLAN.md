---
phase: 04-web-demo
plan: 02
type: execute
wave: 2
depends_on: [04-01]
files_modified:
  - demo/index.html
  - demo/app.js
autonomous: false
user_setup: []

must_haves:
  truths:
    - "User can see three tabs: Keys, Encrypt, Decrypt"
    - "User can generate a keypair and see it displayed"
    - "User can save generated public and private keys with names"
    - "User can see list of saved keys with name and fingerprint"
    - "User can delete a saved key after confirmation"
    - "User can import a key from CBOR hex"
    - "User can export a key to CBOR hex"
    - "User can select a recipient from saved public keys"
    - "User can paste a one-time public key for encryption"
    - "User can enter plaintext and encrypt to selected recipient"
    - "User sees QR code and copy button after encryption"
    - "Opening URL with fragment auto-switches to Decrypt tab"
    - "User can decrypt message using saved private keys"
    - "Decryption shows which key was used"
    - "Error messages appear inline in red"
  artifacts:
    - path: "demo/index.html"
      provides: "Single-page app with dark theme UI"
      contains: "tailwindcss"
      min_lines: 200
    - path: "demo/app.js"
      provides: "Application logic for tabs, encryption, decryption"
      min_lines: 200
  key_links:
    - from: "demo/app.js"
      to: "demo/lib.js"
      via: "dynamic import"
      pattern: "import.*lib\\.js"
    - from: "demo/app.js"
      to: "demo/keystore.js"
      via: "import"
      pattern: "import.*keystore"
    - from: "demo/index.html"
      to: "demo/app.js"
      via: "script module"
      pattern: "type=\"module\""
---

<objective>
Build the complete web demo UI with key management, encryption, and decryption flows.

Purpose: Deliver a fully functional browser-based encryption demo where users can manage keys, encrypt messages to shareable URLs, and decrypt messages from URL fragments.
Output: Complete demo/index.html and demo/app.js implementing all WEB-01 through WEB-07 requirements.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-web-demo/04-CONTEXT.md
@.planning/phases/04-web-demo/04-RESEARCH.md
@.planning/phases/04-web-demo/04-01-SUMMARY.md
@demo/lib.js
@demo/keystore.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HTML structure with Tailwind dark theme</name>
  <files>
    demo/index.html
  </files>
  <action>
Create `demo/index.html` with the following structure:

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>COSE-HPKE Demo</title>
  <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen">
  <div class="max-w-2xl mx-auto p-4">
    <!-- Header -->
    <header class="mb-6">
      <h1 class="text-2xl font-bold text-white">COSE-HPKE Demo</h1>
      <p class="text-gray-400 text-sm">End-to-end encrypted message sharing</p>
    </header>

    <!-- Tab Navigation -->
    <nav class="flex border-b border-gray-700 mb-6">
      <button data-tab="keys" class="tab-btn px-4 py-2 text-gray-400 hover:text-white border-b-2 border-transparent hover:border-gray-500 transition-colors">
        Keys
      </button>
      <button data-tab="encrypt" class="tab-btn px-4 py-2 text-gray-400 hover:text-white border-b-2 border-transparent hover:border-gray-500 transition-colors">
        Encrypt
      </button>
      <button data-tab="decrypt" class="tab-btn px-4 py-2 text-gray-400 hover:text-white border-b-2 border-transparent hover:border-gray-500 transition-colors">
        Decrypt
      </button>
    </nav>

    <!-- Keys Tab -->
    <div data-panel="keys" class="tab-panel hidden">
      <!-- Generate Section -->
      <div class="bg-gray-800 rounded-lg p-4 mb-4">
        <h2 class="text-lg font-semibold mb-3">Generate New Keypair</h2>
        <div class="flex gap-2 mb-3">
          <input type="text" id="new-key-name" placeholder="Key name (e.g., Alice)"
            class="flex-1 bg-gray-700 border border-gray-600 text-gray-100 rounded px-3 py-2 focus:border-blue-500 focus:ring-1 focus:ring-blue-500 outline-none">
          <button id="generate-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-medium px-4 py-2 rounded transition-colors">
            Generate
          </button>
        </div>
        <div id="generate-result" class="hidden">
          <div class="bg-gray-700 rounded p-3 mb-3">
            <pre id="generated-diagnostic" class="text-xs text-gray-300 whitespace-pre-wrap font-mono overflow-x-auto"></pre>
          </div>
          <div class="flex gap-2">
            <button id="save-public-btn" class="bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded text-sm transition-colors">
              Save Public Key
            </button>
            <button id="save-private-btn" class="bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded text-sm transition-colors">
              Save Private Key
            </button>
            <button id="save-both-btn" class="bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded text-sm transition-colors">
              Save Both
            </button>
          </div>
        </div>
        <p id="generate-error" class="text-red-400 text-sm mt-2 hidden"></p>
      </div>

      <!-- Import Section -->
      <div class="bg-gray-800 rounded-lg p-4 mb-4">
        <h2 class="text-lg font-semibold mb-3">Import Key</h2>
        <div class="flex gap-2 mb-2">
          <input type="text" id="import-name" placeholder="Key name"
            class="w-32 bg-gray-700 border border-gray-600 text-gray-100 rounded px-3 py-2 focus:border-blue-500 focus:ring-1 focus:ring-blue-500 outline-none">
          <select id="import-type"
            class="bg-gray-700 border border-gray-600 text-gray-100 rounded px-3 py-2 focus:border-blue-500 outline-none">
            <option value="public">Public</option>
            <option value="private">Private</option>
          </select>
        </div>
        <textarea id="import-hex" placeholder="CBOR hex (from CLI export)"
          class="w-full bg-gray-700 border border-gray-600 text-gray-100 rounded px-3 py-2 focus:border-blue-500 focus:ring-1 focus:ring-blue-500 outline-none font-mono text-xs h-20 resize-none"></textarea>
        <button id="import-btn" class="mt-2 bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded transition-colors">
          Import
        </button>
        <p id="import-error" class="text-red-400 text-sm mt-2 hidden"></p>
        <p id="import-success" class="text-green-400 text-sm mt-2 hidden"></p>
      </div>

      <!-- Saved Keys List -->
      <div class="bg-gray-800 rounded-lg p-4">
        <h2 class="text-lg font-semibold mb-3">Saved Keys</h2>

        <h3 class="text-sm font-medium text-gray-400 mb-2">Public Keys</h3>
        <div id="public-keys-list" class="mb-4">
          <p class="text-gray-500 text-sm">No public keys saved</p>
        </div>

        <h3 class="text-sm font-medium text-gray-400 mb-2">Private Keys</h3>
        <div id="private-keys-list">
          <p class="text-gray-500 text-sm">No private keys saved</p>
        </div>
      </div>
    </div>

    <!-- Encrypt Tab -->
    <div data-panel="encrypt" class="tab-panel hidden">
      <div class="bg-gray-800 rounded-lg p-4">
        <h2 class="text-lg font-semibold mb-3">Encrypt Message</h2>

        <!-- Recipient Selection -->
        <div class="mb-4">
          <label class="block text-sm text-gray-400 mb-1">Recipient</label>
          <select id="recipient-select"
            class="w-full bg-gray-700 border border-gray-600 text-gray-100 rounded px-3 py-2 focus:border-blue-500 outline-none mb-2">
            <option value="">-- Select saved key --</option>
          </select>
          <div class="text-gray-500 text-sm mb-2">Or paste a one-time public key:</div>
          <textarea id="recipient-paste" placeholder="CBOR hex of public key"
            class="w-full bg-gray-700 border border-gray-600 text-gray-100 rounded px-3 py-2 focus:border-blue-500 focus:ring-1 focus:ring-blue-500 outline-none font-mono text-xs h-16 resize-none"></textarea>
        </div>

        <!-- Message Input -->
        <div class="mb-4">
          <label class="block text-sm text-gray-400 mb-1">Message</label>
          <textarea id="plaintext-input" placeholder="Enter your message..."
            class="w-full bg-gray-700 border border-gray-600 text-gray-100 rounded px-3 py-2 focus:border-blue-500 focus:ring-1 focus:ring-blue-500 outline-none h-32 resize-none"></textarea>
        </div>

        <button id="encrypt-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-medium px-4 py-2 rounded transition-colors">
          Encrypt
        </button>

        <p id="encrypt-error" class="text-red-400 text-sm mt-2 hidden"></p>

        <!-- Result -->
        <div id="encrypt-result" class="hidden mt-4">
          <div class="bg-gray-700 rounded p-4 text-center">
            <canvas id="qr-canvas" class="mx-auto mb-3" style="image-rendering: pixelated; width: 200px; height: 200px;"></canvas>
            <p class="text-sm text-gray-400 mb-2">Scan QR code or copy link:</p>
            <div class="flex gap-2">
              <input type="text" id="shareable-url" readonly
                class="flex-1 bg-gray-600 border border-gray-500 text-gray-100 rounded px-3 py-2 text-xs font-mono">
              <button id="copy-url-btn" class="bg-gray-600 hover:bg-gray-500 text-white px-3 py-2 rounded transition-colors">
                Copy
              </button>
            </div>
            <p id="copy-success" class="text-green-400 text-sm mt-2 hidden">Copied!</p>
          </div>
        </div>
      </div>
    </div>

    <!-- Decrypt Tab -->
    <div data-panel="decrypt" class="tab-panel hidden">
      <div class="bg-gray-800 rounded-lg p-4">
        <h2 class="text-lg font-semibold mb-3">Decrypt Message</h2>

        <div id="decrypt-no-keys" class="hidden">
          <p class="text-gray-400 mb-3">No private keys saved. You need a private key to decrypt messages.</p>
          <button id="go-to-keys-btn" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded transition-colors">
            Go to Keys
          </button>
        </div>

        <div id="decrypt-ready">
          <div id="decrypt-from-url" class="hidden mb-4 bg-gray-700 rounded p-3">
            <p class="text-sm text-gray-400 mb-2">Encrypted message detected in URL:</p>
            <p id="url-fragment-preview" class="text-xs font-mono text-gray-300 truncate"></p>
          </div>

          <div class="mb-4">
            <label class="block text-sm text-gray-400 mb-1">Or paste encrypted URL/fragment:</label>
            <input type="text" id="decrypt-input" placeholder="https://...#... or just the fragment"
              class="w-full bg-gray-700 border border-gray-600 text-gray-100 rounded px-3 py-2 focus:border-blue-500 focus:ring-1 focus:ring-blue-500 outline-none font-mono text-xs">
          </div>

          <button id="decrypt-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-medium px-4 py-2 rounded transition-colors">
            Decrypt
          </button>

          <p id="decrypt-error" class="text-red-400 text-sm mt-2 hidden"></p>

          <div id="decrypt-result" class="hidden mt-4">
            <div class="bg-gray-700 rounded p-4">
              <p class="text-sm text-gray-400 mb-2">Decrypted with key: <span id="used-key-name" class="text-green-400"></span></p>
              <pre id="decrypted-text" class="text-gray-100 whitespace-pre-wrap"></pre>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Help Modal (hidden by default) -->
    <div id="help-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4">
      <div class="bg-gray-800 rounded-lg p-6 max-w-md">
        <h2 class="text-xl font-bold mb-4">How to Use</h2>
        <ol class="list-decimal list-inside space-y-2 text-gray-300">
          <li>Generate a keypair in the Keys tab</li>
          <li>Save both public and private keys</li>
          <li>Share your public key with others (export as hex)</li>
          <li>To send a message: Go to Encrypt, select recipient's public key, enter message, click Encrypt</li>
          <li>Share the generated URL or QR code</li>
          <li>Recipient opens URL to decrypt with their private key</li>
        </ol>
        <button id="close-help" class="mt-4 bg-gray-700 hover:bg-gray-600 text-white px-4 py-2 rounded transition-colors">
          Close
        </button>
      </div>
    </div>

    <!-- Footer with help link -->
    <footer class="mt-8 text-center text-gray-500 text-sm">
      <button id="help-btn" class="hover:text-gray-300 transition-colors">
        How to use
      </button>
      <span class="mx-2">|</span>
      <a href="https://github.com/cose-hpke/cose-hpke" class="hover:text-gray-300 transition-colors" target="_blank">
        GitHub
      </a>
    </footer>
  </div>

  <script type="module" src="./app.js"></script>
</body>
</html>
```
  </action>
  <verify>
- File exists at `demo/index.html`
- HTML is valid (no unclosed tags)
- Tailwind CDN script is in head
- Three tab panels exist (keys, encrypt, decrypt)
- All required input fields and buttons are present
  </verify>
  <done>
HTML structure exists with dark theme, three tabs, and all UI elements for key management, encryption, and decryption.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create application JavaScript with full functionality</name>
  <files>
    demo/app.js
  </files>
  <action>
Create `demo/app.js` implementing all application logic:

```javascript
// COSE-HPKE Web Demo Application

import { getKeys, getKeysByType, saveKey, deleteKey, hexToBytes, bytesToHex, getKeyFingerprint } from './keystore.js';

// Dynamic import of the library (allows better error handling)
let lib;

async function initLibrary() {
  lib = await import('./lib.js');
}

// ========== Tab Management ==========

function switchTab(tabName) {
  // Update tab buttons
  document.querySelectorAll('.tab-btn').forEach(btn => {
    const isActive = btn.dataset.tab === tabName;
    btn.classList.toggle('text-white', isActive);
    btn.classList.toggle('border-blue-500', isActive);
    btn.classList.toggle('text-gray-400', !isActive);
    btn.classList.toggle('border-transparent', !isActive);
  });

  // Update panels
  document.querySelectorAll('.tab-panel').forEach(panel => {
    panel.classList.toggle('hidden', panel.dataset.panel !== tabName);
  });

  // Refresh content based on tab
  if (tabName === 'keys') refreshKeysList();
  if (tabName === 'encrypt') refreshRecipientSelect();
  if (tabName === 'decrypt') checkDecryptReady();
}

// ========== Keys Tab ==========

let generatedKeypair = null;
let generatedKeyName = '';

async function handleGenerate() {
  const nameInput = document.getElementById('new-key-name');
  const name = nameInput.value.trim();

  if (!name) {
    showError('generate-error', 'Please enter a key name');
    return;
  }

  hideError('generate-error');

  try {
    generatedKeypair = await lib.generateKeyPair();
    generatedKeyName = name;

    // Show diagnostic
    const pubDiag = lib.toDiagnostic(generatedKeypair.publicKey);
    const privDiag = lib.toDiagnostic(generatedKeypair.privateKey);

    document.getElementById('generated-diagnostic').textContent =
      `Public Key:\n${pubDiag}\n\nPrivate Key:\n${privDiag}`;

    document.getElementById('generate-result').classList.remove('hidden');
  } catch (err) {
    showError('generate-error', `Generation failed: ${err.message}`);
  }
}

function handleSavePublic() {
  if (!generatedKeypair) return;
  try {
    saveKey(generatedKeyName, generatedKeypair.publicKey, 'public');
    refreshKeysList();
    showSuccess('generate-error', 'Public key saved'); // reuse error element for success
  } catch (err) {
    showError('generate-error', err.message);
  }
}

function handleSavePrivate() {
  if (!generatedKeypair) return;
  try {
    saveKey(generatedKeyName, generatedKeypair.privateKey, 'private');
    refreshKeysList();
    showSuccess('generate-error', 'Private key saved');
  } catch (err) {
    showError('generate-error', err.message);
  }
}

function handleSaveBoth() {
  if (!generatedKeypair) return;
  try {
    saveKey(generatedKeyName, generatedKeypair.publicKey, 'public');
    saveKey(generatedKeyName, generatedKeypair.privateKey, 'private');
    refreshKeysList();
    showSuccess('generate-error', 'Both keys saved');
  } catch (err) {
    showError('generate-error', err.message);
  }
}

async function handleImport() {
  const name = document.getElementById('import-name').value.trim();
  const type = document.getElementById('import-type').value;
  const hex = document.getElementById('import-hex').value.trim();

  hideError('import-error');
  hideSuccess('import-success');

  if (!name || !hex) {
    showError('import-error', 'Please enter name and CBOR hex');
    return;
  }

  try {
    const bytes = hexToBytes(hex);
    // Validate it's a valid COSE_Key
    lib.decodeCoseKey(bytes);

    saveKey(name, bytes, type);
    refreshKeysList();

    // Clear inputs
    document.getElementById('import-name').value = '';
    document.getElementById('import-hex').value = '';

    showSuccess('import-success', `${type} key imported`);
  } catch (err) {
    showError('import-error', `Import failed: ${err.message}`);
  }
}

async function refreshKeysList() {
  const publicList = document.getElementById('public-keys-list');
  const privateList = document.getElementById('private-keys-list');

  const publicKeys = getKeysByType('public');
  const privateKeys = getKeysByType('private');

  publicList.innerHTML = publicKeys.length === 0
    ? '<p class="text-gray-500 text-sm">No public keys saved</p>'
    : '';

  privateList.innerHTML = privateKeys.length === 0
    ? '<p class="text-gray-500 text-sm">No private keys saved</p>'
    : '';

  for (const key of publicKeys) {
    const fingerprint = await getKeyFingerprint(hexToBytes(key.keyHex));
    publicList.appendChild(createKeyItem(key, fingerprint));
  }

  for (const key of privateKeys) {
    const fingerprint = await getKeyFingerprint(hexToBytes(key.keyHex));
    privateList.appendChild(createKeyItem(key, fingerprint));
  }
}

function createKeyItem(key, fingerprint) {
  const div = document.createElement('div');
  div.className = 'flex items-center justify-between bg-gray-700 rounded px-3 py-2 mb-2';

  div.innerHTML = `
    <div>
      <span class="font-medium">${escapeHtml(key.name)}</span>
      <span class="text-gray-400 text-xs ml-2">${fingerprint}</span>
    </div>
    <div class="flex gap-1">
      <button class="export-btn text-gray-400 hover:text-white text-sm px-2" data-name="${escapeHtml(key.name)}" data-type="${key.type}">
        Export
      </button>
      <button class="delete-btn text-red-400 hover:text-red-300 text-sm px-2" data-name="${escapeHtml(key.name)}" data-type="${key.type}">
        Delete
      </button>
    </div>
  `;

  // Add event listeners
  div.querySelector('.export-btn').addEventListener('click', () => handleExport(key));
  div.querySelector('.delete-btn').addEventListener('click', () => handleDelete(key));

  return div;
}

function handleExport(key) {
  // Copy hex to clipboard
  navigator.clipboard.writeText(key.keyHex).then(() => {
    alert(`${key.type} key "${key.name}" copied to clipboard (CBOR hex)`);
  });
}

function handleDelete(key) {
  if (confirm(`Delete ${key.type} key "${key.name}"?`)) {
    deleteKey(key.name, key.type);
    refreshKeysList();
    refreshRecipientSelect();
  }
}

// ========== Encrypt Tab ==========

function refreshRecipientSelect() {
  const select = document.getElementById('recipient-select');
  const publicKeys = getKeysByType('public');

  select.innerHTML = '<option value="">-- Select saved key --</option>';

  publicKeys.forEach(key => {
    const option = document.createElement('option');
    option.value = key.keyHex;
    option.textContent = key.name;
    select.appendChild(option);
  });
}

async function handleEncrypt() {
  const selectValue = document.getElementById('recipient-select').value;
  const pasteValue = document.getElementById('recipient-paste').value.trim();
  const plaintext = document.getElementById('plaintext-input').value;

  hideError('encrypt-error');
  document.getElementById('encrypt-result').classList.add('hidden');

  if (!plaintext) {
    showError('encrypt-error', 'Please enter a message');
    return;
  }

  // Determine recipient key
  let recipientHex;
  if (selectValue) {
    recipientHex = selectValue;
  } else if (pasteValue) {
    recipientHex = pasteValue;
  } else {
    showError('encrypt-error', 'Please select or paste a recipient public key');
    return;
  }

  try {
    const recipientKey = hexToBytes(recipientHex);
    // Validate
    lib.decodeCoseKey(recipientKey);

    const plaintextBytes = new TextEncoder().encode(plaintext);
    const ciphertext = await lib.encrypt(plaintextBytes, [recipientKey]);
    const url = await lib.createShareableUrl(ciphertext);

    // Display result
    document.getElementById('shareable-url').value = url;
    document.getElementById('encrypt-result').classList.remove('hidden');

    // Generate QR code
    await generateQrCode(url);

  } catch (err) {
    showError('encrypt-error', `Encryption failed: ${err.message}`);
  }
}

async function generateQrCode(url) {
  // Use lean-qr via dynamic import from CDN
  try {
    const { generate } = await import('https://esm.sh/lean-qr@2');
    const canvas = document.getElementById('qr-canvas');
    const qr = generate(url);
    qr.toCanvas(canvas);
  } catch (err) {
    console.error('QR generation failed:', err);
    // Fallback: hide QR canvas
    document.getElementById('qr-canvas').style.display = 'none';
  }
}

function handleCopyUrl() {
  const url = document.getElementById('shareable-url').value;
  navigator.clipboard.writeText(url).then(() => {
    const successEl = document.getElementById('copy-success');
    successEl.classList.remove('hidden');
    setTimeout(() => successEl.classList.add('hidden'), 2000);
  });
}

// ========== Decrypt Tab ==========

let pendingFragment = null;

function checkDecryptReady() {
  const privateKeys = getKeysByType('private');
  const noKeysDiv = document.getElementById('decrypt-no-keys');
  const readyDiv = document.getElementById('decrypt-ready');

  if (privateKeys.length === 0) {
    noKeysDiv.classList.remove('hidden');
    readyDiv.classList.add('hidden');
  } else {
    noKeysDiv.classList.add('hidden');
    readyDiv.classList.remove('hidden');
  }
}

async function handleDecrypt() {
  const input = document.getElementById('decrypt-input').value.trim();
  const urlFragment = pendingFragment;

  hideError('decrypt-error');
  document.getElementById('decrypt-result').classList.add('hidden');

  // Determine what to decrypt
  let fragment;
  if (input) {
    // User input takes precedence
    if (input.includes('#')) {
      fragment = input.split('#')[1];
    } else if (input.startsWith('http')) {
      showError('decrypt-error', 'URL has no fragment');
      return;
    } else {
      fragment = input;
    }
  } else if (urlFragment) {
    fragment = urlFragment;
  } else {
    showError('decrypt-error', 'Please enter a URL or fragment to decrypt');
    return;
  }

  try {
    const ciphertext = await lib.decodeFragment(fragment);
    const privateKeys = getKeysByType('private');

    // Try all private keys
    let result = null;
    let usedKeyName = '';

    for (const key of privateKeys) {
      try {
        const privateKeyBytes = hexToBytes(key.keyHex);
        const plaintext = await lib.decrypt(ciphertext, privateKeyBytes);
        result = plaintext;
        usedKeyName = key.name;
        break;
      } catch {
        // Try next key
        continue;
      }
    }

    if (result) {
      const text = new TextDecoder().decode(result);
      document.getElementById('used-key-name').textContent = usedKeyName;
      document.getElementById('decrypted-text').textContent = text;
      document.getElementById('decrypt-result').classList.remove('hidden');

      // Clear the URL fragment after successful decrypt
      if (pendingFragment) {
        history.replaceState(null, '', window.location.pathname);
        pendingFragment = null;
        document.getElementById('decrypt-from-url').classList.add('hidden');
      }
    } else {
      showError('decrypt-error', 'Decryption failed: No matching private key found');
    }

  } catch (err) {
    showError('decrypt-error', `Decryption failed: ${err.message}`);
  }
}

function checkUrlFragment() {
  const hash = window.location.hash;
  if (hash && hash.length > 1) {
    pendingFragment = hash.slice(1);

    // Show preview
    document.getElementById('decrypt-from-url').classList.remove('hidden');
    document.getElementById('url-fragment-preview').textContent =
      pendingFragment.length > 50 ? pendingFragment.slice(0, 50) + '...' : pendingFragment;

    // Switch to decrypt tab
    switchTab('decrypt');
  }
}

// ========== Utilities ==========

function showError(elementId, message) {
  const el = document.getElementById(elementId);
  el.textContent = message;
  el.classList.remove('hidden', 'text-green-400');
  el.classList.add('text-red-400');
}

function hideError(elementId) {
  document.getElementById(elementId).classList.add('hidden');
}

function showSuccess(elementId, message) {
  const el = document.getElementById(elementId);
  el.textContent = message;
  el.classList.remove('hidden', 'text-red-400');
  el.classList.add('text-green-400');
}

function hideSuccess(elementId) {
  document.getElementById(elementId).classList.add('hidden');
}

function escapeHtml(str) {
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}

// ========== Event Listeners ==========

function setupEventListeners() {
  // Tab switching
  document.querySelectorAll('.tab-btn').forEach(btn => {
    btn.addEventListener('click', () => switchTab(btn.dataset.tab));
  });

  // Keys tab
  document.getElementById('generate-btn').addEventListener('click', handleGenerate);
  document.getElementById('save-public-btn').addEventListener('click', handleSavePublic);
  document.getElementById('save-private-btn').addEventListener('click', handleSavePrivate);
  document.getElementById('save-both-btn').addEventListener('click', handleSaveBoth);
  document.getElementById('import-btn').addEventListener('click', handleImport);

  // Encrypt tab
  document.getElementById('encrypt-btn').addEventListener('click', handleEncrypt);
  document.getElementById('copy-url-btn').addEventListener('click', handleCopyUrl);

  // Decrypt tab
  document.getElementById('decrypt-btn').addEventListener('click', handleDecrypt);
  document.getElementById('go-to-keys-btn').addEventListener('click', () => switchTab('keys'));

  // Help modal
  document.getElementById('help-btn').addEventListener('click', () => {
    document.getElementById('help-modal').classList.remove('hidden');
  });
  document.getElementById('close-help').addEventListener('click', () => {
    document.getElementById('help-modal').classList.add('hidden');
  });
}

// ========== Initialization ==========

async function init() {
  await initLibrary();
  setupEventListeners();

  // Check for URL fragment first
  checkUrlFragment();

  // If no fragment, default to Keys tab
  if (!pendingFragment) {
    switchTab('keys');
  }
}

// Start the app
init().catch(err => {
  console.error('Failed to initialize:', err);
  document.body.innerHTML = `<div class="p-8 text-red-400">Failed to load: ${err.message}</div>`;
});
```
  </action>
  <verify>
- File exists at `demo/app.js`
- File imports from keystore.js and lib.js
- All event handlers are connected
- Tab switching works (switchTab function)
- URL fragment check happens on load
  </verify>
  <done>
Application JavaScript exists with complete functionality for tab navigation, key management, encryption with QR code, and decryption with auto-key selection.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify demo works in browser</name>
  <what-built>Complete web demo with key management, encryption, and decryption</what-built>
  <how-to-verify>
1. Start a local server:
   ```bash
   cd demo && python3 -m http.server 8000
   ```

2. Open http://localhost:8000 in browser

3. Test Keys tab:
   - Enter a name (e.g., "Test") and click Generate
   - Verify keypair diagnostic is shown
   - Click "Save Both" and verify keys appear in the list
   - Test Export (should copy hex to clipboard)
   - Test Delete with confirmation

4. Test Encrypt tab:
   - Select your public key as recipient
   - Enter a message
   - Click Encrypt
   - Verify QR code appears and URL is generated
   - Copy the URL

5. Test Decrypt tab:
   - Paste the URL into the input field
   - Click Decrypt
   - Verify message is decrypted and key name is shown

6. Test URL fragment flow:
   - Open the shareable URL directly (with #fragment)
   - Verify it auto-switches to Decrypt tab
   - Verify "Encrypted message detected" notice appears
   - Click Decrypt to verify it works

7. Verify dark theme looks correct throughout
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
All tests pass:
```bash
bun test
```

Demo serves correctly:
```bash
cd demo && python3 -m http.server 8000
# Visit http://localhost:8000
```
</verification>

<success_criteria>
1. demo/index.html exists with dark theme and three tabs
2. demo/app.js exists with complete application logic
3. Keys can be generated, saved, imported, exported, deleted
4. Messages can be encrypted to saved or pasted public keys
5. QR code and copy button work for shareable URLs
6. Opening URL with fragment auto-decrypts
7. Error messages display inline in red
</success_criteria>

<output>
After completion, create `.planning/phases/04-web-demo/04-02-SUMMARY.md`
</output>
