---
phase: 02-cli
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/cli/commands/encrypt.ts
  - src/cli/commands/decrypt.ts
  - src/cli/util/url.ts
  - src/cli/util/io.ts
  - src/cli/index.ts
autonomous: true

must_haves:
  truths:
    - "User can encrypt a message and receive a shareable URL"
    - "User can encrypt with --output flag and get a .cose file"
    - "User can decrypt from a URL and see plaintext"
    - "User can decrypt from a file path and see plaintext"
  artifacts:
    - path: "src/cli/commands/encrypt.ts"
      provides: "encrypt subcommand"
      exports: ["default encrypt command"]
    - path: "src/cli/commands/decrypt.ts"
      provides: "decrypt subcommand"
      exports: ["default decrypt command"]
    - path: "src/cli/util/url.ts"
      provides: "URL encoding/decoding for shareable links"
      exports: ["createShareableUrl", "parseShareableUrl", "toBase64Url", "fromBase64Url"]
    - path: "src/cli/util/io.ts"
      provides: "File I/O utilities"
      exports: ["readKeyFile", "readInput"]
  key_links:
    - from: "src/cli/commands/encrypt.ts"
      to: "src/index.ts"
      via: "encrypt function import"
      pattern: "import.*encrypt.*from"
    - from: "src/cli/commands/decrypt.ts"
      to: "src/index.ts"
      via: "decrypt function import"
      pattern: "import.*decrypt.*from"
    - from: "src/cli/commands/encrypt.ts"
      to: "src/cli/util/url.ts"
      via: "URL creation"
      pattern: "createShareableUrl"
    - from: "src/cli/commands/decrypt.ts"
      to: "src/cli/util/url.ts"
      via: "URL parsing"
      pattern: "parseShareableUrl|fromBase64Url"
---

<objective>
Implement encrypt and decrypt CLI commands with URL and file I/O support.

Purpose: Complete the CLI with all cryptographic operations, enabling end-to-end encrypted message sharing.
Output: Working encrypt command (URL output by default, file with --output) and decrypt command (accepts URL or file path).
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-cli/02-CONTEXT.md
@.planning/phases/02-cli/02-RESEARCH.md
@src/index.ts
@src/cli/index.ts (from 02-01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create URL and I/O utility modules</name>
  <files>
    - src/cli/util/url.ts
    - src/cli/util/io.ts
  </files>
  <action>
1. Create src/cli/util/url.ts:
   - toBase64Url(bytes: Uint8Array): string
     - Convert bytes to base64url encoding (no padding)
     - Use btoa + replace +/ with -_
   - fromBase64Url(str: string): Uint8Array
     - Reverse of toBase64Url
     - Handle missing padding
   - createShareableUrl(ciphertext: Uint8Array): string
     - Encode ciphertext as base64url
     - Return URL with fragment: `https://cose-hpke.github.io/decrypt#${base64url}`
     - Note: Base URL is placeholder, will be configured in Phase 4
   - parseShareableUrl(url: string): Uint8Array | null
     - Extract fragment from URL
     - Decode base64url to bytes
     - Return null if URL doesn't have valid fragment
   - isUrl(input: string): boolean
     - Check if input looks like a URL (starts with http:// or https://)

2. Create src/cli/util/io.ts:
   - readKeyFile(path: string): Promise<Uint8Array>
     - Read file as binary using Bun.file().arrayBuffer()
     - Return Uint8Array
   - readInput(source: string): Promise<Uint8Array>
     - If source is "-", read from stdin (Bun.stdin.stream())
     - Otherwise, read from file path
   - writeOutput(path: string, data: Uint8Array): Promise<void>
     - Write binary data to file using Bun.write()
  </action>
  <verify>
    - TypeScript compiles without errors: `bun run typecheck`
    - toBase64Url and fromBase64Url are inverses (manual test or unit test)
  </verify>
  <done>
    URL and I/O utilities created with proper binary handling
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement encrypt command</name>
  <files>
    - src/cli/commands/encrypt.ts
    - src/cli/index.ts
  </files>
  <action>
1. Create src/cli/commands/encrypt.ts:
   - Import defineCommand from citty
   - Import encrypt from library (src/index.ts)
   - Import readKeyFile from ../util/io.ts
   - Import createShareableUrl from ../util/url.ts

   - Define command with:
     - meta: { name: 'encrypt', description: 'Encrypt a message for recipients' }
     - args:
       - message: { type: 'positional', description: 'Message to encrypt', required: true }
       - recipient: { type: 'string', alias: 'r', description: 'Recipient public key file (can repeat for multiple)', required: true }
       - output: { type: 'string', alias: 'o', description: 'Output to file instead of URL' }

   - async run({ args }):
     - Collect recipient keys: handle both single and array (citty may give array for repeated flags)
     - Read each recipient key file as Uint8Array
     - Encode message as Uint8Array: new TextEncoder().encode(args.message)
     - Call encrypt(plaintext, recipientKeys)
     - If args.output:
       - Write ciphertext to file using Bun.write()
       - console.log(`Encrypted message saved to: ${args.output}`)
     - Else:
       - Create shareable URL
       - console.log(url)

   - Export default command

2. Update src/cli/index.ts:
   - Import encrypt from './commands/encrypt.ts'
   - Add to subCommands: { keygen, encrypt }
  </action>
  <verify>
    - Create test key: `bun run cli keygen > /tmp/testkey.txt` (extract public key hex to file)
    - Actually: need to save key to file first. For verification:
      1. Generate keypair and manually save public key CBOR bytes to file
      2. Or add a quick test that creates keys programmatically
    - `bun run cli encrypt "hello" -r /tmp/pub.cose` outputs a URL starting with https://
    - `bun run cli encrypt "hello" -r /tmp/pub.cose --output /tmp/test.cose` creates file
  </verify>
  <done>
    encrypt command accepts message and recipient key, outputs URL or file
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement decrypt command and add tests</name>
  <files>
    - src/cli/commands/decrypt.ts
    - src/cli/index.ts
    - test/cli-encrypt-decrypt.test.ts
  </files>
  <action>
1. Create src/cli/commands/decrypt.ts:
   - Import defineCommand from citty
   - Import decrypt from library (src/index.ts)
   - Import readKeyFile, readInput from ../util/io.ts
   - Import parseShareableUrl, fromBase64Url, isUrl from ../util/url.ts

   - Define command with:
     - meta: { name: 'decrypt', description: 'Decrypt a COSE-HPKE message' }
     - args:
       - input: { type: 'positional', description: 'URL, file path, or - for stdin', required: true }
       - key: { type: 'string', alias: 'k', description: 'Private key file', required: true }

   - async run({ args }):
     - Read private key from file
     - Determine input source:
       - If isUrl(args.input): parse URL fragment with parseShareableUrl()
       - Else: read from file/stdin with readInput()
     - Call decrypt(ciphertext, privateKey)
     - Output plaintext: console.log(new TextDecoder().decode(plaintext))

   - Export default command

2. Update src/cli/index.ts:
   - Import decrypt from './commands/decrypt.ts'
   - Add to subCommands: { keygen, encrypt, decrypt }

3. Create test/cli-encrypt-decrypt.test.ts:
   - Import test utilities and library functions directly for setup
   - Test: encrypt to URL, parse URL, decrypt -> original message
   - Test: encrypt to file, read file, decrypt -> original message
   - Test: encrypt command exits 0 with valid args
   - Test: decrypt command exits 0 with valid input

   Test approach:
   - Generate keypair programmatically using library
   - Save keys to temp files
   - Run CLI commands via Bun shell
   - Verify output matches expected
  </action>
  <verify>
    - `bun run cli --help` lists keygen, encrypt, decrypt
    - Round-trip test: encrypt message -> get URL -> decrypt URL -> original message
    - `bun test` passes all tests including new encrypt/decrypt tests
  </verify>
  <done>
    decrypt command works with URL and file inputs; full round-trip verified
  </done>
</task>

</tasks>

<verification>
Overall phase checks:
1. `bun run cli --help` shows all three commands (keygen, encrypt, decrypt)
2. Round-trip encryption/decryption works via CLI
3. URL output contains base64url-encoded ciphertext in fragment
4. File output creates valid CBOR binary
5. `bun test` passes all tests
6. `bun run typecheck` passes
</verification>

<success_criteria>
- encrypt command outputs shareable URL by default (CLI-04)
- encrypt --output flag saves binary CBOR to file (CLI-05)
- decrypt accepts URL or file path (CLI-06)
- All CLI requirements (CLI-01 through CLI-07) satisfied
- Tests verify round-trip encryption/decryption
</success_criteria>

<output>
After completion, create `.planning/phases/02-cli/02-02-SUMMARY.md`
</output>
