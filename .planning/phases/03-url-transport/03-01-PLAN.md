---
phase: 03-url-transport
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/url/compress.ts
  - src/url/fragment.ts
  - src/url/index.ts
  - src/index.ts
  - src/cli/util/url.ts
  - src/cli/commands/encrypt.ts
  - test/url-transport.test.ts
autonomous: true

must_haves:
  truths:
    - "Encrypted COSE message is compressed before URL encoding"
    - "Compressed data is encoded as base64url and placed in URL fragment"
    - "URL fragment can be decoded, decompressed, and decrypted to original plaintext"
    - "Fragment data never appears in URL path"
    - "Existing URLs without version prefix still work (backward compatibility)"
  artifacts:
    - path: "src/url/compress.ts"
      provides: "compress/decompress functions using CompressionStream"
      exports: ["compress", "decompress", "isCompressionAvailable"]
    - path: "src/url/fragment.ts"
      provides: "URL fragment encoding/decoding with version prefix"
      exports: ["encodeFragment", "decodeFragment", "toBase64Url", "fromBase64Url"]
    - path: "src/url/index.ts"
      provides: "Public URL transport API"
      exports: ["createShareableUrl", "parseShareableUrl", "UrlTooLargeError"]
    - path: "test/url-transport.test.ts"
      provides: "Tests for compression and URL transport"
      min_lines: 50
  key_links:
    - from: "src/url/fragment.ts"
      to: "src/url/compress.ts"
      via: "import compress/decompress"
      pattern: "import.*from.*compress"
    - from: "src/url/index.ts"
      to: "src/url/fragment.ts"
      via: "import encodeFragment/decodeFragment"
      pattern: "import.*from.*fragment"
    - from: "src/cli/util/url.ts"
      to: "src/url/index.ts"
      via: "re-export or delegate to library"
      pattern: "import.*from.*src/url"
    - from: "src/index.ts"
      to: "src/url/index.ts"
      via: "export url module"
      pattern: "export.*from.*url"
---

<objective>
Add compression to URL transport layer for efficient encrypted message sharing

Purpose: Enable smaller shareable URLs by compressing COSE messages before base64url encoding. The URL fragment approach keeps encrypted content client-side (never sent to server). Compression is done at the library level so both CLI and browser can use it.

Output:
- New `src/url/` module with compression and fragment encoding
- CLI updated to use compressed URLs
- Tests verifying round-trip and backward compatibility
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-url-transport/03-RESEARCH.md

# Existing code to integrate with
@src/cli/util/url.ts
@src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create URL transport library module</name>
  <files>
    - src/url/compress.ts
    - src/url/fragment.ts
    - src/url/index.ts
    - src/index.ts
  </files>
  <action>
Create new `src/url/` directory with three modules:

**src/url/compress.ts** - Compression helpers:
- `compress(data: Uint8Array): Promise<Uint8Array>` - Uses CompressionStream with 'deflate-raw' algorithm. Use the `new Response(stream).arrayBuffer()` pattern for Safari compatibility (NOT for-await iteration).
- `decompress(data: Uint8Array): Promise<Uint8Array>` - Uses DecompressionStream with 'deflate-raw'. Wrap in try-catch, throw clear error on invalid data.
- `isCompressionAvailable(): boolean` - Returns `typeof CompressionStream !== 'undefined'`

**src/url/fragment.ts** - Fragment encoding with version prefix:
- Version bytes: `VERSION_UNCOMPRESSED = 0x00`, `VERSION_DEFLATE_RAW = 0x01`
- `toBase64Url(bytes: Uint8Array): string` - Move from cli/util/url.ts (exact same implementation)
- `fromBase64Url(str: string): Uint8Array` - Move from cli/util/url.ts (exact same implementation)
- `encodeFragment(data: Uint8Array): Promise<string>` - Compress, prepend version byte, base64url encode. If compression makes data LARGER, use VERSION_UNCOMPRESSED instead. If CompressionStream unavailable, use uncompressed.
- `decodeFragment(fragment: string): Promise<Uint8Array>` - Decode base64url, check version byte, decompress if needed. For backward compatibility: if first byte is NOT 0x00 or 0x01, assume it's a legacy uncompressed fragment without version prefix (try direct fromBase64Url).

**src/url/index.ts** - Public API:
- `UrlTooLargeError` class with `actualSize` and `maxSize` properties. Message: "URL exceeds maximum length: X.XXMB > 2.00MB limit"
- `MAX_URL_LENGTH = 2 * 1024 * 1024` (2MB Chrome limit)
- `BASE_URL = 'https://cose-hpke.github.io/decrypt'`
- `createShareableUrl(ciphertext: Uint8Array, baseUrl?: string): Promise<string>` - Encode fragment, build URL, validate size, throw UrlTooLargeError if too large
- `parseShareableUrl(url: string): Promise<Uint8Array>` - Parse URL, extract fragment, decode (handles both versioned and legacy fragments)
- Re-export: toBase64Url, fromBase64Url, encodeFragment, decodeFragment from fragment.ts
- Re-export: compress, decompress, isCompressionAvailable from compress.ts

**src/index.ts** - Add export for url module:
- Add `export * from './url/index.ts'` at the end of exports

Use .ts file extensions in imports (project uses allowImportingTsExtensions).
  </action>
  <verify>
Run `bun run build` (or type-check if no build script). No TypeScript errors. Files exist at expected paths.
  </verify>
  <done>
URL transport module exists at src/url/ with compress.ts, fragment.ts, and index.ts. Module is exported from main library entry point.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update CLI to use library compression</name>
  <files>
    - src/cli/util/url.ts
    - src/cli/commands/encrypt.ts
  </files>
  <action>
**src/cli/util/url.ts** - Refactor to use library:
- Remove local toBase64Url and fromBase64Url implementations
- Import from library: `import { createShareableUrl, parseShareableUrl, UrlTooLargeError } from '../../url/index.ts'`
- Re-export: `export { createShareableUrl, parseShareableUrl, toBase64Url, fromBase64Url, UrlTooLargeError } from '../../url/index.ts'`
- Keep `isUrl(input: string): boolean` function (CLI-specific utility)

**src/cli/commands/encrypt.ts** - Handle async URL creation:
- The createShareableUrl function is now async (returns Promise)
- Update the encrypt command to await createShareableUrl
- Catch UrlTooLargeError and show user-friendly message suggesting --output flag

No changes needed to decrypt.ts - parseShareableUrl handles both versioned and legacy formats automatically.
  </action>
  <verify>
Run existing CLI tests: `bun test test/cli-encrypt-decrypt.test.ts`. Tests should pass (URLs will now be compressed but decrypt handles both formats).
  </verify>
  <done>
CLI uses library compression. createShareableUrl call is awaited. UrlTooLargeError caught with helpful message.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add URL transport tests</name>
  <files>
    - test/url-transport.test.ts
  </files>
  <action>
Create comprehensive tests for the URL transport module:

**Compression tests:**
- `compress/decompress round-trip` - Random data compresses and decompresses to original
- `compression reduces size for repetitive data` - Verify compressed.length < original.length for "aaaa..." pattern
- `decompress throws on invalid data` - Verify error message for corrupted input

**Fragment encoding tests:**
- `encodeFragment/decodeFragment round-trip` - Data survives encode->decode
- `encodeFragment uses compression when beneficial` - Check first byte is 0x01 for compressible data
- `encodeFragment skips compression when it would expand` - Small/random data gets 0x00 prefix
- `decodeFragment handles legacy (no version prefix) fragments` - Create legacy fragment manually (no version byte), verify it decodes correctly

**URL creation tests:**
- `createShareableUrl creates valid URL with fragment` - URL has # followed by base64url data
- `createShareableUrl uses compression` - Verify fragment starts differently than raw base64url
- `parseShareableUrl extracts and decompresses ciphertext` - Full round-trip
- `createShareableUrl throws UrlTooLargeError for oversized data` - Create 3MB payload, expect error with size info
- `fragment data never in URL path` - Verify parsed.pathname does not contain ciphertext

**End-to-end test:**
- `full encrypt -> URL -> decrypt round-trip with compression` - Use library encrypt/decrypt with URL transport in between. Verify plaintext matches.

Use standard Bun test patterns from existing tests. Import from library (not CLI utils).
  </action>
  <verify>
Run `bun test test/url-transport.test.ts`. All tests pass.
Run `bun test` for full suite - no regressions.
  </verify>
  <done>
URL transport tests pass. Full test suite shows no regressions. Compression, fragment encoding, URL creation, and backward compatibility all verified.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Type check passes:** `bun run build` or `bunx tsc --noEmit`
2. **All tests pass:** `bun test`
3. **CLI still works:**
   ```bash
   # Generate keys
   bun run src/cli/index.ts keygen > /tmp/keypair.cbor

   # Encrypt (should produce compressed URL)
   echo "Hello compressed world" | bun run src/cli/index.ts encrypt -r /tmp/keypair.cbor

   # Decrypt from URL (should decompress and decrypt)
   echo "Hello compressed world" | bun run src/cli/index.ts encrypt -r /tmp/keypair.cbor | xargs bun run src/cli/index.ts decrypt -k /tmp/keypair.cbor
   ```
4. **Compression working:** URL fragment should be smaller than uncompressed base64url for text messages
</verification>

<success_criteria>
- URL transport module exists at src/url/ and is exported from main library
- Compression uses deflate-raw via CompressionStream
- Version prefix byte (0x00 or 0x01) prepended to all fragments
- Legacy URLs without version prefix still work
- UrlTooLargeError thrown for URLs exceeding 2MB
- All tests pass including new url-transport tests
- CLI produces compressed URLs by default
- Requirements URL-01 through URL-04 satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/03-url-transport/03-01-SUMMARY.md`
</output>
