---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/cose/headers.ts
  - src/cose/aad.ts
  - src/cose/encrypt0.ts
  - src/cose/encrypt.ts
  - src/cose/recipient.ts
  - src/hpke/suite.ts
  - src/hpke/integrated.ts
  - src/hpke/key-encryption.ts
  - src/cose/key.ts
  - src/index.ts
  - test/encrypt.test.ts
  - test/decrypt.test.ts
autonomous: true

must_haves:
  truths:
    - "User can encrypt a message to a single recipient using integrated encryption (COSE_Encrypt0)"
    - "User can encrypt a message to multiple recipients using key encryption (COSE_Encrypt)"
    - "User can decrypt messages from both encryption modes using their private key"
    - "Single encrypt() function auto-selects format based on recipient count"
  artifacts:
    - path: "src/hpke/suite.ts"
      provides: "HPKE-7 cipher suite configuration"
      exports: ["getHpke7Suite"]
    - path: "src/cose/encrypt0.ts"
      provides: "COSE_Encrypt0 structure handling"
      exports: ["buildCoseEncrypt0", "parseCoseEncrypt0"]
    - path: "src/cose/encrypt.ts"
      provides: "COSE_Encrypt structure handling"
      exports: ["buildCoseEncrypt", "parseCoseEncrypt"]
    - path: "src/hpke/integrated.ts"
      provides: "Integrated encryption mode"
      exports: ["encryptIntegrated", "decryptIntegrated"]
    - path: "src/hpke/key-encryption.ts"
      provides: "Key encryption mode"
      exports: ["encryptKeyEncryption", "decryptKeyEncryption"]
    - path: "src/index.ts"
      provides: "Public API"
      exports: ["encrypt", "decrypt", "fromJwk", "toJwk"]
  key_links:
    - from: "src/hpke/integrated.ts"
      to: "src/cose/aad.ts"
      via: "Enc_structure AAD construction"
      pattern: "buildEncStructure"
    - from: "src/hpke/integrated.ts"
      to: "hpke"
      via: "HPKE Seal operation"
      pattern: "seal|Seal"
    - from: "src/index.ts"
      to: "src/hpke/integrated.ts"
      via: "encrypt function routing"
      pattern: "encryptIntegrated"
    - from: "src/index.ts"
      to: "src/hpke/key-encryption.ts"
      via: "encrypt function routing"
      pattern: "encryptKeyEncryption"
---

<objective>
Implement HPKE-7 encryption and decryption for both integrated (single recipient) and key encryption (multi-recipient) modes, with automatic format selection.

Purpose: Complete the core cryptographic functionality that enables end-to-end encrypted message sharing. This is the heart of the library.

Output: Working `encrypt()` and `decrypt()` functions with JWK conversion helpers, supporting both COSE_Encrypt0 and COSE_Encrypt structures.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement COSE structures and HPKE-7 integrated encryption</name>
  <files>src/hpke/suite.ts, src/cose/headers.ts, src/cose/aad.ts, src/cose/encrypt0.ts, src/hpke/integrated.ts</files>
  <action>
Build the integrated encryption mode (COSE_Encrypt0) for single-recipient scenarios:

1. src/hpke/suite.ts - HPKE-7 cipher suite configuration:
```typescript
import { CipherSuite, Kem, Kdf, Aead } from 'hpke';

// HPKE-7: DHKEM(P-256, HKDF-SHA256), HKDF-SHA256, AES-256-GCM
export function getHpke7Suite(): CipherSuite {
  return new CipherSuite({
    kem: Kem.DhkemP256HkdfSha256,
    kdf: Kdf.HkdfSha256,
    aead: Aead.Aes256Gcm,
  });
}
```

Note: Check the exact hpke package API for how to construct CipherSuite. May use different pattern like:
```typescript
import { DhkemP256HkdfSha256, HkdfSha256, Aes256Gcm, CipherSuite } from 'hpke';
```

2. src/cose/headers.ts - Protected/unprotected header handling:
```typescript
import { encode, decode } from '../util/cbor';
import { HEADER_ALG, HEADER_EK } from '../types/hpke';

export type HeaderMap = Map<number, unknown>;

export function buildProtectedHeader(alg: number): Uint8Array {
  const header = new Map<number, number>();
  header.set(HEADER_ALG, alg);
  return encode(header);
}

export function parseProtectedHeader(bytes: Uint8Array): HeaderMap {
  return decode(bytes) as HeaderMap;
}

export function buildUnprotectedHeader(ek: Uint8Array): HeaderMap {
  const header = new Map<number, Uint8Array>();
  header.set(HEADER_EK, ek);
  return header;
}
```

3. src/cose/aad.ts - Enc_structure for AAD per RFC 9052 Section 5.3:
```typescript
import { encode } from '../util/cbor';

// Enc_structure = [context, protected, external_aad]
export function buildEncStructure(
  context: 'Encrypt0' | 'Encrypt' | 'Enc_Recipient',
  protectedHeader: Uint8Array,
  externalAad: Uint8Array = new Uint8Array()
): Uint8Array {
  return encode([context, protectedHeader, externalAad]);
}
```

4. src/cose/encrypt0.ts - COSE_Encrypt0 structure (Tag 16):
```typescript
import { encode, decode } from '../util/cbor';
import { Tag } from 'cbor2';
import { COSE_ENCRYPT0_TAG } from '../types/cose';
import type { HeaderMap } from './headers';

export interface CoseEncrypt0 {
  protectedHeader: Uint8Array;
  unprotectedHeader: HeaderMap;
  ciphertext: Uint8Array;
}

export function buildCoseEncrypt0(data: CoseEncrypt0): Uint8Array {
  return encode(new Tag(COSE_ENCRYPT0_TAG, [
    data.protectedHeader,
    data.unprotectedHeader,
    data.ciphertext,
  ]));
}

export function parseCoseEncrypt0(bytes: Uint8Array): CoseEncrypt0 {
  const decoded = decode(bytes);

  // Handle tagged or untagged input
  let arr: unknown[];
  if (decoded instanceof Tag) {
    if (decoded.tag !== COSE_ENCRYPT0_TAG) {
      throw new Error(`Expected COSE_Encrypt0 tag (16), got ${decoded.tag}`);
    }
    arr = decoded.value as unknown[];
  } else if (Array.isArray(decoded)) {
    arr = decoded;
  } else {
    throw new Error('Invalid COSE_Encrypt0 structure');
  }

  if (arr.length !== 3) {
    throw new Error('COSE_Encrypt0 must have 3 elements');
  }

  return {
    protectedHeader: arr[0] as Uint8Array,
    unprotectedHeader: arr[1] as HeaderMap,
    ciphertext: arr[2] as Uint8Array,
  };
}
```

5. src/hpke/integrated.ts - Integrated encryption mode:
```typescript
import { getHpke7Suite } from './suite';
import { buildProtectedHeader, buildUnprotectedHeader, parseProtectedHeader } from '../cose/headers';
import { buildEncStructure } from '../cose/aad';
import { buildCoseEncrypt0, parseCoseEncrypt0 } from '../cose/encrypt0';
import { decodeCoseKey, coseKeyToCryptoKey } from '../cose/key';
import { ALG_HPKE_7_INTEGRATED, HEADER_EK } from '../types/hpke';
import { DecryptionError, InvalidKeyError } from '../errors';

export async function encryptIntegrated(
  plaintext: Uint8Array,
  recipientPublicKey: Uint8Array
): Promise<Uint8Array> {
  const suite = getHpke7Suite();

  // Decode recipient's COSE_Key and convert to CryptoKey
  const recipientCoseKey = decodeCoseKey(recipientPublicKey);
  const recipientCryptoKey = await coseKeyToCryptoKey(recipientCoseKey, 'public');

  // Build protected header
  const protectedHeader = buildProtectedHeader(ALG_HPKE_7_INTEGRATED);

  // Build AAD (Enc_structure)
  const aad = buildEncStructure('Encrypt0', protectedHeader);

  // HPKE Seal
  const sender = await suite.createSenderContext({
    recipientPublicKey: recipientCryptoKey,
  });

  const ciphertext = await sender.seal(plaintext, aad);
  const encapsulatedKey = sender.enc;  // The encapsulated key

  // Build unprotected header with encapsulated key
  const unprotectedHeader = buildUnprotectedHeader(new Uint8Array(encapsulatedKey));

  // Build and return COSE_Encrypt0
  return buildCoseEncrypt0({
    protectedHeader,
    unprotectedHeader,
    ciphertext: new Uint8Array(ciphertext),
  });
}

export async function decryptIntegrated(
  coseMessage: Uint8Array,
  recipientPrivateKey: Uint8Array
): Promise<Uint8Array> {
  const suite = getHpke7Suite();

  // Parse COSE_Encrypt0
  const encrypt0 = parseCoseEncrypt0(coseMessage);

  // Get encapsulated key from unprotected header
  const ek = encrypt0.unprotectedHeader.get(HEADER_EK) as Uint8Array;
  if (!ek) {
    throw new DecryptionError('Missing encapsulated key (ek) in header');
  }

  // Decode private key
  const privateCoseKey = decodeCoseKey(recipientPrivateKey);
  const privateCryptoKey = await coseKeyToCryptoKey(privateCoseKey, 'private');

  // Build AAD (must match encryption)
  const aad = buildEncStructure('Encrypt0', encrypt0.protectedHeader);

  // HPKE Open
  try {
    const recipient = await suite.createRecipientContext({
      recipientKey: privateCryptoKey,
      enc: ek,
    });

    const plaintext = await recipient.open(encrypt0.ciphertext, aad);
    return new Uint8Array(plaintext);
  } catch (error) {
    throw new DecryptionError(
      'Decryption failed',
      error instanceof Error ? error.message : 'Unknown error'
    );
  }
}
```

Note: The hpke package API may differ. Adjust method names (e.g., `seal` vs `Seal`, `createSenderContext` vs `setupBaseS`). Consult the @panva/hpke documentation for exact API.

6. Update src/cose/key.ts - Add CryptoKey conversion helpers:
```typescript
// Add to existing key.ts

export async function coseKeyToCryptoKey(
  coseKey: CoseKeyMap,
  type: 'public' | 'private'
): Promise<CryptoKey> {
  const kty = coseKey.get(COSE_KEY_KTY);
  if (kty !== KTY_EC2) {
    throw new InvalidKeyError(`Unsupported key type: ${kty}`);
  }

  const x = coseKey.get(COSE_KEY_X) as Uint8Array;
  const y = coseKey.get(COSE_KEY_Y) as Uint8Array;
  const d = coseKey.get(COSE_KEY_D) as Uint8Array | undefined;

  // Build JWK
  const jwk: JsonWebKey = {
    kty: 'EC',
    crv: 'P-256',
    x: base64UrlEncode(x),
    y: base64UrlEncode(y),
  };

  if (type === 'private') {
    if (!d) {
      throw new InvalidKeyError('Private key requires d parameter');
    }
    jwk.d = base64UrlEncode(d);
  }

  // Import as CryptoKey
  const keyUsages: KeyUsage[] = type === 'private'
    ? ['deriveBits', 'deriveKey']
    : [];

  return crypto.subtle.importKey(
    'jwk',
    jwk,
    { name: 'ECDH', namedCurve: 'P-256' },
    true,
    keyUsages
  );
}

function base64UrlEncode(bytes: Uint8Array): string {
  const binary = String.fromCharCode(...bytes);
  const base64 = btoa(binary);
  return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
}
```
  </action>
  <verify>
    - `bun run typecheck` passes
    - Files exist at specified paths
    - Types are properly exported
  </verify>
  <done>
    - HPKE-7 suite configured
    - Enc_structure AAD construction working
    - COSE_Encrypt0 build/parse implemented
    - encryptIntegrated and decryptIntegrated functions complete
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement key encryption mode (multi-recipient)</name>
  <files>src/cose/recipient.ts, src/cose/encrypt.ts, src/hpke/key-encryption.ts</files>
  <action>
Build the key encryption mode (COSE_Encrypt) for multi-recipient scenarios:

1. src/cose/recipient.ts - COSE_recipient structure:
```typescript
import { encode, decode } from '../util/cbor';
import type { HeaderMap } from './headers';

export interface CoseRecipient {
  protectedHeader: Uint8Array;
  unprotectedHeader: HeaderMap;
  ciphertext: Uint8Array;  // Encrypted CEK
}

export function buildCoseRecipient(data: CoseRecipient): unknown[] {
  return [
    data.protectedHeader,
    data.unprotectedHeader,
    data.ciphertext,
  ];
}

export function parseCoseRecipient(arr: unknown[]): CoseRecipient {
  if (arr.length !== 3) {
    throw new Error('COSE_recipient must have 3 elements');
  }

  return {
    protectedHeader: arr[0] as Uint8Array,
    unprotectedHeader: arr[1] as HeaderMap,
    ciphertext: arr[2] as Uint8Array,
  };
}
```

2. src/cose/encrypt.ts - COSE_Encrypt structure (Tag 96):
```typescript
import { encode, decode } from '../util/cbor';
import { Tag } from 'cbor2';
import { COSE_ENCRYPT_TAG } from '../types/cose';
import type { HeaderMap } from './headers';
import { type CoseRecipient, parseCoseRecipient, buildCoseRecipient } from './recipient';

export interface CoseEncrypt {
  protectedHeader: Uint8Array;
  unprotectedHeader: HeaderMap;
  ciphertext: Uint8Array;  // Content encrypted with CEK
  recipients: CoseRecipient[];
}

export function buildCoseEncrypt(data: CoseEncrypt): Uint8Array {
  const recipients = data.recipients.map(buildCoseRecipient);

  return encode(new Tag(COSE_ENCRYPT_TAG, [
    data.protectedHeader,
    data.unprotectedHeader,
    data.ciphertext,
    recipients,
  ]));
}

export function parseCoseEncrypt(bytes: Uint8Array): CoseEncrypt {
  const decoded = decode(bytes);

  let arr: unknown[];
  if (decoded instanceof Tag) {
    if (decoded.tag !== COSE_ENCRYPT_TAG) {
      throw new Error(`Expected COSE_Encrypt tag (96), got ${decoded.tag}`);
    }
    arr = decoded.value as unknown[];
  } else if (Array.isArray(decoded)) {
    arr = decoded;
  } else {
    throw new Error('Invalid COSE_Encrypt structure');
  }

  if (arr.length !== 4) {
    throw new Error('COSE_Encrypt must have 4 elements');
  }

  const recipientArrays = arr[3] as unknown[][];
  const recipients = recipientArrays.map(parseCoseRecipient);

  return {
    protectedHeader: arr[0] as Uint8Array,
    unprotectedHeader: arr[1] as HeaderMap,
    ciphertext: arr[2] as Uint8Array,
    recipients,
  };
}
```

3. src/hpke/key-encryption.ts - Key encryption mode:
```typescript
import { getHpke7Suite } from './suite';
import { buildProtectedHeader, buildUnprotectedHeader } from '../cose/headers';
import { buildEncStructure } from '../cose/aad';
import { buildCoseEncrypt, parseCoseEncrypt, type CoseEncrypt } from '../cose/encrypt';
import { type CoseRecipient } from '../cose/recipient';
import { decodeCoseKey, coseKeyToCryptoKey } from '../cose/key';
import { ALG_HPKE_7_INTEGRATED, ALG_HPKE_7_KEY_ENCRYPTION, HEADER_EK } from '../types/hpke';
import { HEADER_ALG } from '../types/hpke';
import { DecryptionError, InvalidKeyError } from '../errors';
import { encode } from '../util/cbor';

// AES-256-GCM for content encryption
const CEK_LENGTH = 32;  // 256 bits for AES-256

export async function encryptKeyEncryption(
  plaintext: Uint8Array,
  recipientPublicKeys: Uint8Array[]
): Promise<Uint8Array> {
  if (recipientPublicKeys.length === 0) {
    throw new InvalidKeyError('At least one recipient required');
  }

  // Generate random CEK (Content Encryption Key)
  const cek = crypto.getRandomValues(new Uint8Array(CEK_LENGTH));

  // Build protected header for content layer (no alg, since recipients provide it)
  const contentProtectedHeader = encode(new Map());  // Empty protected header for content

  // Encrypt content with CEK using AES-256-GCM
  const iv = crypto.getRandomValues(new Uint8Array(12));  // 96-bit IV
  const contentKey = await crypto.subtle.importKey(
    'raw',
    cek,
    { name: 'AES-GCM', length: 256 },
    false,
    ['encrypt']
  );

  // AAD for content encryption
  const contentAad = buildEncStructure('Encrypt', contentProtectedHeader);

  const ciphertext = await crypto.subtle.encrypt(
    { name: 'AES-GCM', iv, additionalData: contentAad },
    contentKey,
    plaintext
  );

  // Content unprotected header contains IV
  const contentUnprotectedHeader = new Map<number, Uint8Array>();
  contentUnprotectedHeader.set(5, iv);  // IV parameter

  // Encrypt CEK to each recipient using HPKE
  const recipients: CoseRecipient[] = [];
  const suite = getHpke7Suite();

  for (const pubKeyBytes of recipientPublicKeys) {
    const coseKey = decodeCoseKey(pubKeyBytes);
    const cryptoKey = await coseKeyToCryptoKey(coseKey, 'public');

    // Recipient protected header
    const recipientProtectedHeader = buildProtectedHeader(ALG_HPKE_7_KEY_ENCRYPTION);

    // AAD for recipient
    const recipientAad = buildEncStructure('Enc_Recipient', recipientProtectedHeader);

    // HPKE seal the CEK
    const sender = await suite.createSenderContext({
      recipientPublicKey: cryptoKey,
    });

    const encryptedCek = await sender.seal(cek, recipientAad);
    const encapsulatedKey = sender.enc;

    // Recipient unprotected header with encapsulated key
    const recipientUnprotectedHeader = buildUnprotectedHeader(new Uint8Array(encapsulatedKey));

    recipients.push({
      protectedHeader: recipientProtectedHeader,
      unprotectedHeader: recipientUnprotectedHeader,
      ciphertext: new Uint8Array(encryptedCek),
    });
  }

  // Build COSE_Encrypt
  return buildCoseEncrypt({
    protectedHeader: contentProtectedHeader,
    unprotectedHeader: contentUnprotectedHeader,
    ciphertext: new Uint8Array(ciphertext),
    recipients,
  });
}

export async function decryptKeyEncryption(
  coseMessage: Uint8Array,
  recipientPrivateKey: Uint8Array
): Promise<Uint8Array> {
  const suite = getHpke7Suite();
  const coseEncrypt = parseCoseEncrypt(coseMessage);

  // Decode private key
  const privateCoseKey = decodeCoseKey(recipientPrivateKey);
  const privateCryptoKey = await coseKeyToCryptoKey(privateCoseKey, 'private');

  // Try each recipient layer to find one that works with our key
  let cek: Uint8Array | null = null;

  for (const recipient of coseEncrypt.recipients) {
    try {
      const ek = recipient.unprotectedHeader.get(HEADER_EK) as Uint8Array;
      if (!ek) continue;

      // AAD for recipient
      const recipientAad = buildEncStructure('Enc_Recipient', recipient.protectedHeader);

      // HPKE open to get CEK
      const recipientContext = await suite.createRecipientContext({
        recipientKey: privateCryptoKey,
        enc: ek,
      });

      const decryptedCek = await recipientContext.open(recipient.ciphertext, recipientAad);
      cek = new Uint8Array(decryptedCek);
      break;
    } catch {
      // Try next recipient
      continue;
    }
  }

  if (!cek) {
    throw new DecryptionError('No matching recipient found for the provided key');
  }

  // Decrypt content with CEK
  const iv = coseEncrypt.unprotectedHeader.get(5) as Uint8Array;  // IV parameter
  if (!iv) {
    throw new DecryptionError('Missing IV in content unprotected header');
  }

  const contentKey = await crypto.subtle.importKey(
    'raw',
    cek,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );

  const contentAad = buildEncStructure('Encrypt', coseEncrypt.protectedHeader);

  try {
    const plaintext = await crypto.subtle.decrypt(
      { name: 'AES-GCM', iv, additionalData: contentAad },
      contentKey,
      coseEncrypt.ciphertext
    );

    return new Uint8Array(plaintext);
  } catch (error) {
    throw new DecryptionError(
      'Content decryption failed',
      error instanceof Error ? error.message : 'Unknown error'
    );
  }
}
```
  </action>
  <verify>
    - `bun run typecheck` passes
    - COSE_recipient and COSE_Encrypt structures correctly built
  </verify>
  <done>
    - COSE_recipient structure implemented
    - COSE_Encrypt (multi-recipient) structure implemented
    - encryptKeyEncryption encrypts to multiple recipients
    - decryptKeyEncryption tries all recipients to find matching key
  </done>
</task>

<task type="auto">
  <name>Task 3: Create public API with auto-detection and JWK helpers</name>
  <files>src/cose/key.ts, src/index.ts, test/encrypt.test.ts, test/decrypt.test.ts</files>
  <action>
Create the unified public API and comprehensive tests:

1. Update src/cose/key.ts - Add JWK conversion per CONTEXT.md:
```typescript
// Add to existing key.ts exports

export async function fromJwk(jwk: JsonWebKey): Promise<Uint8Array> {
  if (jwk.kty !== 'EC' || jwk.crv !== 'P-256') {
    throw new InvalidKeyError('Only P-256 EC keys supported', jwk.kty);
  }

  if (!jwk.x || !jwk.y) {
    throw new InvalidKeyError('JWK missing x or y coordinate');
  }

  const map = new Map<number, number | Uint8Array>();
  map.set(COSE_KEY_KTY, KTY_EC2);
  map.set(COSE_KEY_CRV, CRV_P256);
  map.set(COSE_KEY_X, base64UrlDecode(jwk.x));
  map.set(COSE_KEY_Y, base64UrlDecode(jwk.y));

  if (jwk.d) {
    map.set(COSE_KEY_D, base64UrlDecode(jwk.d));
  }

  return encode(map);
}

export async function toJwk(coseKeyBytes: Uint8Array): Promise<JsonWebKey> {
  const coseKey = decodeCoseKey(coseKeyBytes);

  const kty = coseKey.get(COSE_KEY_KTY);
  if (kty !== KTY_EC2) {
    throw new InvalidKeyError(`Unsupported key type for JWK: ${kty}`);
  }

  const x = coseKey.get(COSE_KEY_X) as Uint8Array;
  const y = coseKey.get(COSE_KEY_Y) as Uint8Array;
  const d = coseKey.get(COSE_KEY_D) as Uint8Array | undefined;

  const jwk: JsonWebKey = {
    kty: 'EC',
    crv: 'P-256',
    x: base64UrlEncode(x),
    y: base64UrlEncode(y),
  };

  if (d) {
    jwk.d = base64UrlEncode(d);
  }

  return jwk;
}
```

2. Update src/index.ts - Complete public API:
```typescript
// Types
export type { KeyPair, CoseKeyMap } from './types/cose';
export * from './types/cose';
export * from './types/hpke';

// COSE_Key operations
export {
  generateKeyPair,
  encodeCoseKey,
  decodeCoseKey,
  toDiagnostic,
  fromJwk,
  toJwk,
  coseKeyToCryptoKey,
} from './cose/key';

// Errors
export { CoseError, InvalidKeyError, DecryptionError } from './errors';

// Internal imports for API
import { encryptIntegrated, decryptIntegrated } from './hpke/integrated';
import { encryptKeyEncryption, decryptKeyEncryption } from './hpke/key-encryption';
import { decode } from './util/cbor';
import { Tag } from 'cbor2';
import { COSE_ENCRYPT0_TAG, COSE_ENCRYPT_TAG } from './types/cose';
import { InvalidKeyError } from './errors';

/**
 * Encrypt plaintext to one or more recipients.
 *
 * - 1 recipient: Uses integrated encryption (COSE_Encrypt0)
 * - 2+ recipients: Uses key encryption (COSE_Encrypt)
 *
 * @param plaintext - The message to encrypt
 * @param recipients - Array of CBOR-encoded COSE_Key public keys
 * @returns CBOR-encoded COSE message
 */
export async function encrypt(
  plaintext: Uint8Array,
  recipients: Uint8Array[]
): Promise<Uint8Array> {
  if (recipients.length === 0) {
    throw new InvalidKeyError('At least one recipient required');
  }

  if (recipients.length === 1) {
    return encryptIntegrated(plaintext, recipients[0]);
  }

  return encryptKeyEncryption(plaintext, recipients);
}

/**
 * Decrypt a COSE message using the recipient's private key.
 *
 * Auto-detects message format (COSE_Encrypt0 or COSE_Encrypt).
 *
 * @param coseMessage - CBOR-encoded COSE_Encrypt0 or COSE_Encrypt
 * @param privateKey - CBOR-encoded COSE_Key private key
 * @returns Decrypted plaintext
 */
export async function decrypt(
  coseMessage: Uint8Array,
  privateKey: Uint8Array
): Promise<Uint8Array> {
  // Detect message type by CBOR tag
  const decoded = decode(coseMessage);

  if (decoded instanceof Tag) {
    if (decoded.tag === COSE_ENCRYPT0_TAG) {
      return decryptIntegrated(coseMessage, privateKey);
    }
    if (decoded.tag === COSE_ENCRYPT_TAG) {
      return decryptKeyEncryption(coseMessage, privateKey);
    }
    throw new InvalidKeyError(`Unknown COSE tag: ${decoded.tag}`);
  }

  // Untagged - try to detect by array length
  if (Array.isArray(decoded)) {
    if (decoded.length === 3) {
      return decryptIntegrated(coseMessage, privateKey);
    }
    if (decoded.length === 4) {
      return decryptKeyEncryption(coseMessage, privateKey);
    }
  }

  throw new InvalidKeyError('Unable to determine COSE message type');
}
```

3. test/encrypt.test.ts - Encryption tests:
```typescript
import { describe, it, expect } from 'bun:test';
import { generateKeyPair, encrypt, decrypt, toDiagnostic } from '../src';

describe('encrypt', () => {
  describe('single recipient (integrated encryption)', () => {
    it('encrypts and decrypts successfully', async () => {
      const { publicKey, privateKey } = await generateKeyPair();
      const plaintext = new TextEncoder().encode('Hello, COSE-HPKE!');

      const ciphertext = await encrypt(plaintext, [publicKey]);
      expect(ciphertext).toBeInstanceOf(Uint8Array);

      const decrypted = await decrypt(ciphertext, privateKey);
      expect(new TextDecoder().decode(decrypted)).toBe('Hello, COSE-HPKE!');
    });

    it('produces COSE_Encrypt0 (tag 16)', async () => {
      const { publicKey } = await generateKeyPair();
      const plaintext = new TextEncoder().encode('test');

      const ciphertext = await encrypt(plaintext, [publicKey]);

      // First byte should be CBOR tag indicator (0xd0 for tag 16)
      // Tag 16 encoded as d0 10
      expect(ciphertext[0]).toBe(0xd0);  // CBOR 1-byte tag marker
    });

    it('fails with wrong private key', async () => {
      const sender = await generateKeyPair();
      const wrongRecipient = await generateKeyPair();
      const plaintext = new TextEncoder().encode('secret');

      const ciphertext = await encrypt(plaintext, [sender.publicKey]);

      await expect(decrypt(ciphertext, wrongRecipient.privateKey)).rejects.toThrow();
    });
  });

  describe('multiple recipients (key encryption)', () => {
    it('encrypts to multiple recipients', async () => {
      const recipient1 = await generateKeyPair();
      const recipient2 = await generateKeyPair();
      const plaintext = new TextEncoder().encode('Multi-recipient message');

      const ciphertext = await encrypt(plaintext, [
        recipient1.publicKey,
        recipient2.publicKey,
      ]);

      // Both recipients can decrypt
      const decrypted1 = await decrypt(ciphertext, recipient1.privateKey);
      const decrypted2 = await decrypt(ciphertext, recipient2.privateKey);

      expect(new TextDecoder().decode(decrypted1)).toBe('Multi-recipient message');
      expect(new TextDecoder().decode(decrypted2)).toBe('Multi-recipient message');
    });

    it('produces COSE_Encrypt (tag 96)', async () => {
      const recipient1 = await generateKeyPair();
      const recipient2 = await generateKeyPair();
      const plaintext = new TextEncoder().encode('test');

      const ciphertext = await encrypt(plaintext, [
        recipient1.publicKey,
        recipient2.publicKey,
      ]);

      // Tag 96 encoded as d8 60
      expect(ciphertext[0]).toBe(0xd8);  // CBOR 2-byte tag marker
      expect(ciphertext[1]).toBe(0x60);  // Tag value 96
    });

    it('only the correct recipients can decrypt', async () => {
      const recipient1 = await generateKeyPair();
      const recipient2 = await generateKeyPair();
      const outsider = await generateKeyPair();
      const plaintext = new TextEncoder().encode('Private message');

      const ciphertext = await encrypt(plaintext, [
        recipient1.publicKey,
        recipient2.publicKey,
      ]);

      // Outsider cannot decrypt
      await expect(decrypt(ciphertext, outsider.privateKey)).rejects.toThrow('No matching recipient');
    });
  });

  describe('edge cases', () => {
    it('throws on empty recipients array', async () => {
      const plaintext = new TextEncoder().encode('test');
      await expect(encrypt(plaintext, [])).rejects.toThrow('At least one recipient');
    });

    it('handles empty plaintext', async () => {
      const { publicKey, privateKey } = await generateKeyPair();
      const plaintext = new Uint8Array(0);

      const ciphertext = await encrypt(plaintext, [publicKey]);
      const decrypted = await decrypt(ciphertext, privateKey);

      expect(decrypted.length).toBe(0);
    });

    it('handles large plaintext', async () => {
      const { publicKey, privateKey } = await generateKeyPair();
      const plaintext = new Uint8Array(10000).fill(0x42);

      const ciphertext = await encrypt(plaintext, [publicKey]);
      const decrypted = await decrypt(ciphertext, privateKey);

      expect(decrypted).toEqual(plaintext);
    });
  });
});
```

4. test/decrypt.test.ts - Additional decrypt tests:
```typescript
import { describe, it, expect } from 'bun:test';
import { decrypt, InvalidKeyError } from '../src';

describe('decrypt', () => {
  it('throws on invalid CBOR', async () => {
    const invalidBytes = new Uint8Array([0xff, 0xff]);
    const fakeKey = new Uint8Array([0xa0]); // empty map

    await expect(decrypt(invalidBytes, fakeKey)).rejects.toThrow();
  });

  it('throws on unknown COSE tag', async () => {
    // Create a tagged array with wrong tag
    const { encode } = await import('cbor2');
    const { Tag } = await import('cbor2');
    const badMessage = encode(new Tag(999, [new Uint8Array(), new Map(), new Uint8Array()]));
    const fakeKey = new Uint8Array([0xa0]);

    await expect(decrypt(badMessage, fakeKey)).rejects.toThrow('Unknown COSE tag');
  });
});
```
  </action>
  <verify>
    - `bun test` passes all tests
    - `bun run typecheck` passes
    - Single recipient uses COSE_Encrypt0
    - Multiple recipients use COSE_Encrypt
    - Wrong key cannot decrypt
  </verify>
  <done>
    - encrypt() auto-selects format based on recipient count
    - decrypt() auto-detects message format
    - fromJwk() and toJwk() conversion helpers working
    - All encryption/decryption tests pass
    - Phase 1 requirements fully implemented
  </done>
</task>

</tasks>

<verification>
Run the complete test suite:

```bash
bun run typecheck && bun test
```

Manual verification of complete workflow:

```bash
# Generate keypair, encrypt, decrypt (integrated mode)
bun -e "
import { generateKeyPair, encrypt, decrypt, toDiagnostic } from './src';

const { publicKey, privateKey } = await generateKeyPair();
console.log('Public key:', toDiagnostic(publicKey));

const plaintext = new TextEncoder().encode('Hello, COSE-HPKE!');
const ciphertext = await encrypt(plaintext, [publicKey]);
console.log('Ciphertext length:', ciphertext.length);

const decrypted = await decrypt(ciphertext, privateKey);
console.log('Decrypted:', new TextDecoder().decode(decrypted));
"
```

Multi-recipient test:

```bash
# Two recipients, both can decrypt
bun -e "
import { generateKeyPair, encrypt, decrypt } from './src';

const alice = await generateKeyPair();
const bob = await generateKeyPair();

const message = new TextEncoder().encode('Secret for Alice and Bob');
const encrypted = await encrypt(message, [alice.publicKey, bob.publicKey]);

const aliceDecrypted = await decrypt(encrypted, alice.privateKey);
const bobDecrypted = await decrypt(encrypted, bob.privateKey);

console.log('Alice sees:', new TextDecoder().decode(aliceDecrypted));
console.log('Bob sees:', new TextDecoder().decode(bobDecrypted));
"
```
</verification>

<success_criteria>
- [ ] HPKE-7 cipher suite working (CORE-01)
- [ ] Integrated encryption (COSE_Encrypt0) working (CORE-02)
- [ ] Key encryption (COSE_Encrypt) working (CORE-03)
- [ ] Single encrypt() with auto-detection
- [ ] Single decrypt() with format detection
- [ ] JWK conversion helpers (fromJwk, toJwk)
- [ ] All unit tests pass
- [ ] Manual encryption/decryption workflow verified
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
