---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - tsconfig.json
  - src/index.ts
  - src/types/cose.ts
  - src/types/hpke.ts
  - src/util/cbor.ts
  - src/cose/key.ts
  - src/errors.ts
  - test/cose-key.test.ts
autonomous: true

must_haves:
  truths:
    - "User can generate a P-256 keypair and receive it in COSE_Key format"
    - "User can view any key in CDDL diagnostic notation"
    - "COSE_Key can be parsed from and serialized to CBOR bytes"
  artifacts:
    - path: "package.json"
      provides: "Project dependencies and scripts"
      contains: "hpke"
    - path: "src/types/cose.ts"
      provides: "COSE type definitions"
      exports: ["CoseKey", "CoseKeyEC2"]
    - path: "src/cose/key.ts"
      provides: "COSE_Key operations"
      exports: ["generateKeyPair", "encodeCoseKey", "decodeCoseKey", "toDiagnostic"]
    - path: "src/errors.ts"
      provides: "Custom error classes"
      exports: ["CoseError", "InvalidKeyError"]
  key_links:
    - from: "src/cose/key.ts"
      to: "cbor2"
      via: "encode/decode imports"
      pattern: "import.*from.*cbor2"
    - from: "src/cose/key.ts"
      to: "hpke"
      via: "CipherSuite for key generation"
      pattern: "CipherSuite"
    - from: "src/index.ts"
      to: "src/cose/key.ts"
      via: "re-exports"
      pattern: "export.*from.*cose/key"
---

<objective>
Set up the COSE-HPKE project with TypeScript/Bun configuration, core type definitions, CBOR utilities, and COSE_Key implementation for P-256 keypair generation.

Purpose: Establish the foundational layer that all encryption operations depend on. COSE_Key is the fundamental unit for key representation and must be complete before implementing encryption modes.

Output: Working `generateKeyPair()` function that returns P-256 keys in COSE_Key format, with CBOR encoding/decoding and diagnostic notation support.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize project with Bun and dependencies</name>
  <files>package.json, tsconfig.json, .gitignore</files>
  <action>
Initialize Bun project and configure TypeScript:

1. Run `bun init` to create package.json (accept defaults)

2. Install dependencies:
   - `bun add hpke cbor2`
   - `bun add -d typescript @types/bun`

3. Create tsconfig.json with strict mode:
```json
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "declaration": true,
    "outDir": "dist",
    "rootDir": "src",
    "types": ["bun-types"]
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "test"]
}
```

4. Update package.json with project metadata:
   - name: "cose-hpke"
   - version: "0.1.0"
   - type: "module"
   - main: "dist/index.js"
   - exports with types and default
   - scripts: "build", "test", "typecheck"

5. Create .gitignore if not exists (node_modules, dist, *.log)
  </action>
  <verify>
    - `bun run typecheck` completes without errors
    - `cat package.json` shows hpke and cbor2 in dependencies
  </verify>
  <done>
    - package.json exists with correct dependencies
    - tsconfig.json configured for strict TypeScript
    - Project can be type-checked with `bun run typecheck`
  </done>
</task>

<task type="auto">
  <name>Task 2: Create type definitions and CBOR utilities</name>
  <files>src/types/cose.ts, src/types/hpke.ts, src/util/cbor.ts, src/errors.ts</files>
  <action>
Create foundational types and utilities:

1. src/types/cose.ts - COSE type definitions per RFC 9052/9053:
```typescript
// COSE key type values
export const KTY_EC2 = 2;

// COSE curve values
export const CRV_P256 = 1;

// COSE key parameter labels
export const COSE_KEY_KTY = 1;
export const COSE_KEY_CRV = -1;
export const COSE_KEY_X = -2;
export const COSE_KEY_Y = -3;
export const COSE_KEY_D = -4;

// COSE structure tags
export const COSE_ENCRYPT0_TAG = 16;
export const COSE_ENCRYPT_TAG = 96;

// Type for decoded COSE_Key map
export type CoseKeyMap = Map<number, number | Uint8Array>;

// Keypair with CBOR-encoded COSE_Key values
export interface KeyPair {
  publicKey: Uint8Array;   // CBOR-encoded COSE_Key
  privateKey: Uint8Array;  // CBOR-encoded COSE_Key with 'd' parameter
}
```

2. src/types/hpke.ts - HPKE algorithm identifiers per draft-ietf-cose-hpke-20:
```typescript
// Algorithm IDs (TBD values from draft-20)
export const ALG_HPKE_7_INTEGRATED = 45;  // HPKE-7 integrated encryption
export const ALG_HPKE_7_KEY_ENCRYPTION = 53;  // HPKE-7 key encryption

// Header parameter labels
export const HEADER_ALG = 1;
export const HEADER_EK = -4;  // Encapsulated key
export const HEADER_KID = 4;  // Key identifier
```

3. src/util/cbor.ts - Thin wrapper around cbor2:
```typescript
import { encode, decode, diagnose } from 'cbor2';

export { encode, decode };

// Wrapper for diagnostic notation with error handling
export function toDiagnosticNotation(data: Uint8Array): string {
  return diagnose(data);
}
```

4. src/errors.ts - Custom error classes per CONTEXT.md:
```typescript
export class CoseError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'CoseError';
  }
}

export class InvalidKeyError extends CoseError {
  constructor(message: string, public readonly keyType?: string) {
    super(message);
    this.name = 'InvalidKeyError';
  }
}

export class DecryptionError extends CoseError {
  constructor(message: string, public readonly reason?: string) {
    super(message);
    this.name = 'DecryptionError';
  }
}
```
  </action>
  <verify>
    - `bun run typecheck` passes
    - Files exist at specified paths
  </verify>
  <done>
    - COSE constants and types defined in src/types/cose.ts
    - HPKE algorithm IDs defined in src/types/hpke.ts
    - CBOR utilities wrapping cbor2 in src/util/cbor.ts
    - Custom error classes in src/errors.ts
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement COSE_Key operations with tests</name>
  <files>src/cose/key.ts, src/index.ts, test/cose-key.test.ts</files>
  <action>
Implement COSE_Key generation, encoding, decoding, and diagnostic output:

1. src/cose/key.ts - Core COSE_Key implementation:

```typescript
import { CipherSuite } from 'hpke';
import { encode, decode, toDiagnosticNotation } from '../util/cbor';
import {
  KTY_EC2, CRV_P256,
  COSE_KEY_KTY, COSE_KEY_CRV, COSE_KEY_X, COSE_KEY_Y, COSE_KEY_D,
  type KeyPair, type CoseKeyMap
} from '../types/cose';
import { InvalidKeyError } from '../errors';

// HPKE-7: DHKEM(P-256, HKDF-SHA256), HKDF-SHA256, AES-256-GCM
// Import the specific constants from hpke package
const suite = new CipherSuite(/* P-256 KEM, HKDF-SHA256, AES-256-GCM */);

export async function generateKeyPair(): Promise<KeyPair> {
  // Use @panva/hpke to generate P-256 keypair
  const { publicKey, privateKey } = await suite.generateKeyPair();

  // Export to JWK to get raw key material
  const pubJwk = await crypto.subtle.exportKey('jwk', publicKey);
  const privJwk = await crypto.subtle.exportKey('jwk', privateKey);

  // Build COSE_Key maps
  const pubCoseKey = buildCoseKeyEC2(pubJwk);
  const privCoseKey = buildCoseKeyEC2(privJwk);

  return {
    publicKey: encode(pubCoseKey),
    privateKey: encode(privCoseKey),
  };
}

function buildCoseKeyEC2(jwk: JsonWebKey): CoseKeyMap {
  if (!jwk.x || !jwk.y) {
    throw new InvalidKeyError('Missing x or y coordinate', 'EC2');
  }

  const map = new Map<number, number | Uint8Array>();
  map.set(COSE_KEY_KTY, KTY_EC2);
  map.set(COSE_KEY_CRV, CRV_P256);
  map.set(COSE_KEY_X, base64UrlDecode(jwk.x));
  map.set(COSE_KEY_Y, base64UrlDecode(jwk.y));

  if (jwk.d) {
    map.set(COSE_KEY_D, base64UrlDecode(jwk.d));
  }

  return map;
}

export function encodeCoseKey(keyMap: CoseKeyMap): Uint8Array {
  return encode(keyMap);
}

export function decodeCoseKey(bytes: Uint8Array): CoseKeyMap {
  const decoded = decode(bytes);
  if (!(decoded instanceof Map)) {
    throw new InvalidKeyError('COSE_Key must be a CBOR map');
  }

  // Validate required fields
  const kty = decoded.get(COSE_KEY_KTY);
  if (kty !== KTY_EC2) {
    throw new InvalidKeyError(`Unsupported key type: ${kty}`, 'EC2');
  }

  return decoded as CoseKeyMap;
}

export function toDiagnostic(coseKeyBytes: Uint8Array): string {
  return toDiagnosticNotation(coseKeyBytes);
}

// Helper: base64url decode
function base64UrlDecode(str: string): Uint8Array {
  const base64 = str.replace(/-/g, '+').replace(/_/g, '/');
  const pad = base64.length % 4;
  const padded = pad ? base64 + '='.repeat(4 - pad) : base64;
  const binary = atob(padded);
  const bytes = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) {
    bytes[i] = binary.charCodeAt(i);
  }
  return bytes;
}
```

Note: The exact CipherSuite constructor arguments depend on hpke package exports. Check the hpke package API and use the correct constant names (e.g., `Kem.DhkemP256HkdfSha256`, `Kdf.HkdfSha256`, `Aead.Aes256Gcm` or similar).

2. src/index.ts - Public API exports:
```typescript
// Types
export type { KeyPair, CoseKeyMap } from './types/cose';
export * from './types/cose';
export * from './types/hpke';

// COSE_Key operations
export { generateKeyPair, encodeCoseKey, decodeCoseKey, toDiagnostic } from './cose/key';

// Errors
export { CoseError, InvalidKeyError, DecryptionError } from './errors';
```

3. test/cose-key.test.ts - Tests for COSE_Key operations:
```typescript
import { describe, it, expect } from 'bun:test';
import { generateKeyPair, decodeCoseKey, toDiagnostic, COSE_KEY_KTY, COSE_KEY_X, COSE_KEY_Y, COSE_KEY_D, KTY_EC2 } from '../src';

describe('generateKeyPair', () => {
  it('generates a valid P-256 keypair', async () => {
    const { publicKey, privateKey } = await generateKeyPair();

    expect(publicKey).toBeInstanceOf(Uint8Array);
    expect(privateKey).toBeInstanceOf(Uint8Array);

    // Decode and verify structure
    const pubDecoded = decodeCoseKey(publicKey);
    const privDecoded = decodeCoseKey(privateKey);

    // Public key has kty, crv, x, y
    expect(pubDecoded.get(COSE_KEY_KTY)).toBe(KTY_EC2);
    expect(pubDecoded.get(COSE_KEY_X)).toBeInstanceOf(Uint8Array);
    expect(pubDecoded.get(COSE_KEY_Y)).toBeInstanceOf(Uint8Array);
    expect(pubDecoded.has(COSE_KEY_D)).toBe(false);

    // Private key also has d
    expect(privDecoded.get(COSE_KEY_KTY)).toBe(KTY_EC2);
    expect(privDecoded.has(COSE_KEY_D)).toBe(true);
  });

  it('generates unique keypairs each call', async () => {
    const kp1 = await generateKeyPair();
    const kp2 = await generateKeyPair();

    // Keys should be different
    const pub1 = decodeCoseKey(kp1.publicKey);
    const pub2 = decodeCoseKey(kp2.publicKey);

    expect(pub1.get(COSE_KEY_X)).not.toEqual(pub2.get(COSE_KEY_X));
  });
});

describe('toDiagnostic', () => {
  it('outputs CDDL diagnostic notation', async () => {
    const { publicKey } = await generateKeyPair();
    const diag = toDiagnostic(publicKey);

    // Should contain map with expected keys
    expect(diag).toContain('1:');  // kty
    expect(diag).toContain('-1:'); // crv
    expect(diag).toContain('-2:'); // x
    expect(diag).toContain('-3:'); // y
    expect(diag).toContain("h'");  // hex byte strings
  });
});

describe('decodeCoseKey', () => {
  it('throws on invalid CBOR', () => {
    expect(() => decodeCoseKey(new Uint8Array([0xff]))).toThrow();
  });

  it('throws on non-map input', async () => {
    const { encode } = await import('cbor2');
    const arrayBytes = encode([1, 2, 3]);
    expect(() => decodeCoseKey(arrayBytes)).toThrow('must be a CBOR map');
  });
});
```
  </action>
  <verify>
    - `bun test` passes all tests
    - `bun run typecheck` passes
    - Test output shows keypair generation and diagnostic notation working
  </verify>
  <done>
    - generateKeyPair() returns valid P-256 COSE_Key pairs
    - decodeCoseKey() parses CBOR bytes to CoseKeyMap
    - toDiagnostic() outputs CDDL diagnostic notation
    - All tests pass
  </done>
</task>

</tasks>

<verification>
Run the complete test suite and type check:

```bash
bun run typecheck && bun test
```

Manual verification:
```bash
# Quick smoke test - should output key in diagnostic notation
bun -e "import { generateKeyPair, toDiagnostic } from './src'; const kp = await generateKeyPair(); console.log(toDiagnostic(kp.publicKey));"
```

Expected output should show a CBOR map with:
- `1: 2` (kty: EC2)
- `-1: 1` (crv: P-256)
- `-2: h'...'` (x coordinate, 32 bytes hex)
- `-3: h'...'` (y coordinate, 32 bytes hex)
</verification>

<success_criteria>
- [ ] Package.json has hpke and cbor2 dependencies
- [ ] TypeScript compiles without errors
- [ ] generateKeyPair() returns P-256 COSE_Key pairs
- [ ] toDiagnostic() outputs valid CDDL diagnostic notation
- [ ] All unit tests pass
- [ ] Project ready for encryption implementation in Plan 02
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
